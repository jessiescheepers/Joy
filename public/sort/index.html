<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Joy - what does today look like?</title>
<meta property="og:title" content="Joy - what does today look like?">
<meta property="og:description" content="See your capacity for today.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://joy-taupe.vercel.app/sort/index.html">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Joy - what does today look like?">
<link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:ital,wght@0,300;0,400;0,500;0,600;1,300;1,400&family=Source+Serif+4:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&family=DM+Mono:wght@300;400&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #f4efe5;
  --text: #2a2520;
  --muted: rgba(42,37,32,0.38);
  --accent: #b8944e;
  --card-w: min(380px, calc(100vw - 32px));
  --card-h: min(620px, calc(100dvh - 40px));
}

html, body { height: 100%; overflow: hidden; overscroll-behavior: none; }
button { -webkit-tap-highlight-color: transparent; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Source Serif 4', serif;
  min-height: 100vh;
  min-height: 100dvh;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* ═══ SOUND TOGGLE ═══ */
.sound-toggle {
  position: fixed;
  bottom: max(12px, env(safe-area-inset-bottom, 0px));
  right: 12px;
  z-index: 9999;
  width: 40px; height: 40px;
  border: none; border-radius: 50%;
  background: hsla(38, 30%, 93%, 0.6);
  backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
  color: var(--muted);
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  transition: opacity 0.3s ease, color 0.3s ease;
  opacity: 0; pointer-events: none;
}
.sound-toggle.visible { opacity: 1; pointer-events: auto; }
.sound-toggle .sound-icon-off { display: none; }
.sound-toggle.muted .sound-icon-on { display: none; }
.sound-toggle.muted .sound-icon-off { display: block; }
@media (hover: hover) { .sound-toggle:hover { color: var(--text); } }
.sound-toggle::after {
  content: attr(data-dbg);
  position: absolute; top: -16px; right: 0;
  font: 500 10px/1 monospace; color: #999;
}

/* ═══ CARD LAYOUT ═══ */
.card-scene {
  width: var(--card-w);
  height: var(--card-h);
  position: relative;
}

.card {
  width: 100%;
  height: 100%;
  border-radius: 24px;
  overflow: hidden;
  position: relative;
  background: hsl(38, 30%, 93%);
  box-shadow: 0 4px 40px rgba(130,95,35,0.08), 0 1px 3px rgba(130,95,35,0.06);
}

/* ═══ CANVAS — inside card ═══ */
#orb-canvas {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: block;
  z-index: 0;
  border-radius: 24px;
}

/* ═══ CHECKIN BAR — bottom of card ═══ */
.checkin-bar {
  position: absolute;
  bottom: 0; left: 0; right: 0;
  height: 140px;
  z-index: 10;
  pointer-events: none;
  transition: opacity 0.8s ease;
}
.checkin-bar.hidden { opacity: 0; pointer-events: none; }

.checkin-moment {
  display: flex;
  flex-direction: column;
  align-items: center;
  opacity: 0;
  pointer-events: none;
  touch-action: none;
  position: absolute;
  bottom: 0; left: 0; right: 0;
  padding: 16px 20px calc(16px + env(safe-area-inset-bottom, 0px));
  background: linear-gradient(to top,
    hsla(38,30%,93%,0.95) 0%,
    hsla(38,30%,93%,0.8) 50%,
    hsla(38,30%,93%,0) 100%);
}
.checkin-moment.active {
  opacity: 1; pointer-events: auto;
}
.checkin-moment.exit-up {
  animation: momentExitUp 0.4s cubic-bezier(0.4,0,0.2,1) forwards;
  pointer-events: none !important;
}
.checkin-moment.enter-up {
  animation: momentEnterUp 0.45s cubic-bezier(0.16,1,0.3,1) forwards;
  pointer-events: auto !important;
}

@keyframes momentExitUp {
  from { opacity: 1; }
  to { opacity: 0; }
}
@keyframes momentEnterUp {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* ─── Joy Logo (inside card, above question) ─── */
.joy-logo {
  position: absolute;
  top: 12%;
  left: 0; right: 0;
  z-index: 10;
  text-align: center;
  color: rgba(95,75,45,0.55);
  transition: color 0.8s ease, opacity 0.35s ease;
  pointer-events: none;
}
.joy-logo.hidden { opacity: 0; }

/* ─── Question Label (inside card, below logo) ─── */
.top-label {
  position: absolute;
  top: 18%;
  left: 0; right: 0;
  z-index: 10;
  text-align: center;
  font-family: 'Plus Jakarta Sans', sans-serif;
  font-size: 14px;
  letter-spacing: 0.18em;
  text-transform: uppercase;
  color: rgba(40,32,20,0.65);
  transition: opacity 0.35s ease;
  pointer-events: none;
}
.top-label.hidden { opacity: 0; }

/* Hide old in-moment labels */
.question-label { display: none; }

/* ─── Intro prompt (center of card before drawing starts) ─── */
.intro-prompt {
  position: absolute;
  inset: 0;
  z-index: 5;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 40px;
  font-family: 'Source Serif 4', serif;
  font-style: italic;
  font-size: 16px;
  color: rgba(105,78,32,0.55);
  line-height: 1.5;
  transition: opacity 0.6s ease;
  pointer-events: none;
}
.intro-prompt.hidden { opacity: 0; }

/* ─── Horizontal Slider ─── */
.slider-wrap {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  width: 100%;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
}

.slider-readout {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 50px;
}

.slider-number {
  font-family: 'DM Mono', monospace;
  font-size: 32px;
  font-weight: 300;
  line-height: 1;
  color: rgba(40,32,20,0.7);
  letter-spacing: -0.04em;
  transition: transform 0.25s ease-out, color 0.3s;
}
.slider-number.pop {
  transform: scale(1.12);
  color: rgba(40,32,20,0.85);
}

.slider-word {
  font-family: 'Source Serif 4', serif;
  font-style: italic;
  font-size: 17px;
  margin-top: 2px;
  color: rgba(40,32,20,0.62);
  transition: opacity 0.3s ease;
  min-height: 18px;
}

.slider-track-container {
  position: relative;
  width: 100%;
  height: 32px;
  display: flex;
  align-items: center;
}

.slider-track {
  position: relative;
  width: 100%;
  height: 1px;
  background: rgba(130,95,35,0.18);
}

/* T-bar caps — vertical endcaps on horizontal track */
.slider-track::before,
.slider-track::after {
  content: '';
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 1px;
  height: 8px;
  background: rgba(130,95,35,0.22);
}
.slider-track::before { left: 0; }
.slider-track::after { right: 0; }

.slider-fill {
  display: none;
}

.slider-thumb {
  position: absolute;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 19px;
  transition: left 0.35s cubic-bezier(0.34,1.56,0.64,1);
  pointer-events: none;
  z-index: 2;
  filter: drop-shadow(0 0 8px rgba(130,95,35,0.15));
}
.slider-thumb svg {
  width: 100%;
  height: 100%;
  fill: rgb(110,80,28);
  display: block;
}

.slider-tick-labels { display: none; }

/* ─── Progress Dots ─── */
.checkin-progress {
  position: absolute;
  bottom: calc(6px + env(safe-area-inset-bottom, 0px));
  left: 0; right: 0;
  display: flex;
  justify-content: center;
  gap: 8px;
  opacity: 0;
  transition: opacity 0.4s ease;
  pointer-events: none;
}
.checkin-progress.visible { opacity: 1; }
.progress-dot {
  width: 4px; height: 4px; border-radius: 50%;
  background: rgba(130,95,35,0.18);
  transition: background 0.4s ease, transform 0.3s ease;
}
.progress-dot.filled {
  background: rgba(130,95,35,0.5);
  transform: scale(1.15);
}
.progress-dot.current {
  background: rgba(130,95,35,0.3);
}

/* ═══ DONE ACTIONS — after all sliders ═══ */
.done-actions {
  position: absolute;
  bottom: calc(20px + env(safe-area-inset-bottom, 0px));
  left: 0; right: 0;
  display: flex;
  gap: 12px;
  justify-content: center;
  z-index: 10;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.8s ease;
}
.done-actions.visible { opacity: 1; pointer-events: auto; }

.done-btn {
  font-family: 'Plus Jakarta Sans', sans-serif;
  font-size: 12px;
  letter-spacing: 0.1em;
  padding: 14px 20px;
  border-radius: 24px;
  border: 1px solid rgba(130,95,35,0.15);
  background: rgba(244,239,229,0.8);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  color: rgba(120,90,40,0.72);
  cursor: pointer;
  transition: all 0.3s;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
}
.done-btn:hover { border-color: rgba(130,95,35,0.3); color: rgba(120,90,40,0.8); }
.done-btn:active { transform: scale(0.95); }

/* ═══ GIF PROGRESS ═══ */
.gif-progress {
  position: absolute;
  bottom: calc(60px + env(safe-area-inset-bottom, 0px));
  left: 0; right: 0;
  text-align: center;
  font-family: 'Plus Jakarta Sans', sans-serif;
  font-size: 11px;
  letter-spacing: 0.12em;
  color: rgb(120,90,40);
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s;
  z-index: 11;
}
.gif-progress.visible { opacity: 1; }

/* ═══ REVEAL — single centered column ═══ */
@keyframes revealFadeUp {
  from { opacity: 0; transform: translateY(8px); }
  to   { opacity: 1; transform: translateY(0); }
}
.reveal-overlay {
  position: absolute;
  inset: 0;
  z-index: 8;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 48px 32px 88px;
  text-align: center;
  pointer-events: none;
  opacity: 0;
  transition: opacity 1.0s cubic-bezier(0.16, 1, 0.3, 1);
}
.reveal-overlay.visible { opacity: 1; }

/* Animate leaf text elements, not wrapper divs */
.reveal-date, .reveal-capacity, .reveal-timing, .reveal-nudge {
  opacity: 0;
  animation-fill-mode: both;
  animation-duration: 0.8s;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
}
.reveal-overlay.visible .reveal-date,
.reveal-overlay.visible .reveal-capacity,
.reveal-overlay.visible .reveal-timing,
.reveal-overlay.visible .reveal-nudge {
  animation-name: revealFadeUp;
}

/* Top text group */
.reveal-text-top {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex-shrink: 0;
}
/* Shape spacer — pushes bottom text down, flexes to fill available space */
.reveal-spacer {
  flex: 1;
}
/* Bottom text group */
.reveal-text-bottom {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex-shrink: 0;
}

.reveal-date {
  font-family: 'Plus Jakarta Sans', sans-serif;
  font-size: 11px;
  font-weight: 500;
  letter-spacing: 0.2em;
  text-transform: uppercase;
  color: rgba(42,37,32, 0.45);
  margin-bottom: 8px;
  animation-delay: 0.1s;
}
.reveal-capacity {
  font-family: 'Source Serif 4', serif;
  font-weight: 600;
  font-size: 28px;
  line-height: 1.15;
  letter-spacing: -0.01em;
  color: rgba(42,37,32, 0.78);
  text-shadow: 0 0 24px hsla(38,30%,93%,0.7);
  margin-bottom: 6px;
  animation-delay: 0.3s;
}
.reveal-timing {
  font-family: 'Source Serif 4', serif;
  font-weight: 400;
  font-size: 15px;
  line-height: 1.5;
  color: rgba(42,37,32, 0.55);
  max-width: 280px;
  animation-delay: 0.55s;
}
.reveal-nudge {
  font-family: 'Source Serif 4', serif;
  font-weight: 400;
  font-style: italic;
  font-size: 15px;
  line-height: 1.5;
  color: rgba(105,78,32, 0.50);
  max-width: 260px;
  animation-delay: 0.8s;
}

/* ═══ SHARE SHEET ═══ */
.share-backdrop {
  position: fixed;
  inset: 0;
  z-index: 19;
  background: rgba(42,37,32,0.25);
  opacity: 0;
  transition: opacity 0.35s ease;
  pointer-events: none;
}
.share-backdrop.visible { opacity: 1; pointer-events: auto; }

.share-sheet {
  position: fixed;
  bottom: 0; left: 50%;
  transform: translateX(-50%) translateY(100%);
  width: var(--card-w);
  z-index: 20;
  background: hsl(38, 30%, 93%);
  border-radius: 20px 20px 0 0;
  padding: 0 0 calc(16px + env(safe-area-inset-bottom, 0px));
  transition: transform 0.35s cubic-bezier(0.16, 1, 0.3, 1);
  touch-action: none;
}
.share-sheet.visible { transform: translateX(-50%) translateY(0); }

.share-handle {
  width: 36px; height: 4px;
  border-radius: 2px;
  background: rgba(130,95,35,0.2);
  margin: 12px auto 16px;
}

.share-row {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 13px 20px;
  font-family: 'Plus Jakarta Sans', sans-serif;
  font-size: 13px;
  letter-spacing: 0.04em;
  color: rgba(120,90,40,0.75);
  cursor: pointer;
  transition: background 0.15s;
  -webkit-tap-highlight-color: transparent;
  border: none;
  background: none;
  width: 100%;
  text-align: left;
}
.share-row:active { transform: scale(0.97); background: rgba(130,95,35,0.05); }
.share-row svg { flex-shrink: 0; opacity: 0.5; }
.share-row-label { flex: 1; }
.share-row-chevron { opacity: 0.25; }

.share-divider {
  height: 1px;
  background: rgba(130,95,35,0.08);
  margin: 4px 20px;
}

/* ═══ RESPONSIVE ═══ */
@media (max-height: 500px) {
  :root { --card-h: calc(100dvh - 20px); }
  .slider-number { font-size: 22px; }
  .question-label { margin-bottom: 8px; }
  .reveal-overlay { padding: 32px 24px 72px; }
  .reveal-capacity { font-size: 22px; }
  .reveal-timing { font-size: 13px; }
  .reveal-nudge { font-size: 13px; }
}
@media (min-width: 500px) {
  :root { --card-w: 400px; --card-h: min(680px, calc(100dvh - 40px)); }
}

/* ═══ FOCUS INDICATORS ═══ */
.slider-wrap:focus-visible {
  outline: 2px solid rgba(184,148,78,0.6);
  outline-offset: 4px;
  border-radius: 8px;
}
.done-btn:focus-visible {
  outline: 2px solid rgba(184,148,78,0.6);
  outline-offset: 2px;
}

/* ═══ TOUCH TARGET — enlarge slider hit area to 44px ═══ */
.slider-track-container::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 0; right: 0;
  height: 44px;
  transform: translateY(-50%);
}

/* ═══ REDUCED MOTION ═══ */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
</style>
</head>
<body>

<!-- Joy O blob thumb SVG -->
<svg aria-hidden="true" style="position:absolute;width:0;height:0;overflow:hidden">
  <symbol id="joy-o-thumb" viewBox="0 0 71 67">
    <path d="M33.4773 0.00507876C45.9792 -0.237324 54.8639 8.2549 59.6677 13.173C60.8211 14.3538 62.0607 15.3162 63.4822 16.5715C64.8541 17.783 66.2727 19.1721 67.4685 21.0051C69.8981 24.7296 71.2223 29.9882 70.1648 38.801C69.0674 47.945 63.605 54.2959 57.7293 58.4611C51.8735 62.612 45.477 64.6937 42.1375 65.301C35.6426 66.4819 27.5926 67.1949 16.7683 61.4855C11.3039 58.6032 5.60729 53.3343 2.45874 46.4953C-0.717831 39.595 -1.27391 31.1379 3.54273 22.1066C8.17167 13.4274 12.5187 7.91639 17.3425 4.56856C22.2106 1.19016 27.407 0.122949 33.4773 0.00507876Z" fill-rule="evenodd"/>
  </symbol>
</svg>

<!-- iOS audio session activator -->
<audio id="audio-kick" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" preload="auto"></audio>

<button class="sound-toggle" id="sound-toggle" aria-label="Mute sound" onclick="document.getElementById('sound-toggle').classList.toggle('muted', SoundEngine.toggleMute())">
  <svg class="sound-icon-on" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 010 14.14M15.54 8.46a5 5 0 010 7.07"/></svg>
  <svg class="sound-icon-off" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></svg>
</button>

<div class="card-scene">
  <div class="card" id="card">
    <!-- Spirograph canvas -->
    <canvas id="orb-canvas"></canvas>

    <!-- Joy logo (inside card, above question) -->
    <div class="joy-logo" id="joy-logo"><svg width="44" height="24" viewBox="-5 -5 230 120" fill="none" xmlns="http://www.w3.org/2000/svg" aria-label="Joy logo"><g class="joy-letter-j"><path d="M30.2532 21.5356C30.6813 18.0664 31.0359 1.33741 44.968 1.50119C58.9002 1.66498 60.0737 18.5844 61.1451 28.2186C62.2164 37.8527 65.1902 67.8238 62.2164 79.5676C59.2426 91.3114 43.0396 104.795 33.5048 106.186C23.97 107.576 14.8637 103.901 14.8637 103.901C14.8637 103.901 0.122877 97.935 1.60652 88.799C3.09016 79.6631 10.5268 79.5676 14.8637 79.5676C19.2007 79.5676 22.0358 79.5489 23.7478 76.1229C25.4597 72.6969 29.8252 25.0049 30.2532 21.5356Z" fill="currentColor" stroke="currentColor" stroke-width="3"/></g><g class="joy-letter-o"><path d="M106.504 13.8331C119.005 13.5907 127.89 22.0829 132.694 27.0011C133.847 28.1818 135.087 29.1443 136.508 30.3995C137.88 31.6111 139.299 33.0001 140.495 34.8331C142.924 38.5576 144.249 43.8163 143.191 52.629C142.094 61.773 136.631 68.124 130.756 72.2892C124.9 76.4401 118.503 78.5217 115.164 79.129C108.669 80.31 100.619 81.0229 89.7946 75.3136C84.3302 72.4313 78.6335 67.1624 75.485 60.3234C72.3084 53.4231 71.7523 44.9659 76.569 35.9347C81.1979 27.2555 85.5449 21.7444 90.3688 18.3966C95.2368 15.0182 100.433 13.951 106.504 13.8331ZM107.989 39.2657C106.658 39.2915 105.374 39.5298 104.153 40.3741C102.975 41.1886 102.009 42.4625 101.06 44.2345C99.9229 46.3589 100.041 48.4164 100.815 50.0909C101.56 51.7039 102.887 52.9198 104.165 53.5909C106.615 54.8783 108.498 54.7177 109.931 54.4581C110.518 54.3519 112.174 54.089 113.737 53.3663C115.285 52.6501 117.12 51.2975 117.415 48.8488C117.655 46.8555 117.261 45.3616 116.582 44.2032C115.953 43.1318 115.059 42.3659 114.706 42.006C114.08 41.3675 113.094 40.6866 111.968 40.1691C110.836 39.6485 109.44 39.2377 107.989 39.2657Z" fill="currentColor"/></g><g class="joy-letter-y"><path d="M170.747 19.551C190.701 18.3811 181.535 37.6894 182.909 41.2569C184.283 44.8244 188.519 43.4435 189.893 40.5664C191.267 37.6894 191.688 21.4654 205.503 22.6352C219.317 23.8051 219.088 32.0504 219.432 34.5822C219.775 37.114 218.745 53.4555 218.745 53.4555C218.745 53.4555 216.686 85.4898 211.094 94.7425C205.503 103.995 182.794 109.5 172.948 109.5C163.102 109.5 141.912 107.93 144.763 90.2757C147.614 72.6211 176.777 80.9166 180.724 72.6211C184.671 64.3256 162.759 67.3256 157.042 58.7952C151.326 50.2648 152.226 39.3005 152.226 39.3005C152.226 39.3005 150.793 20.7209 170.747 19.551Z" fill="currentColor" stroke="currentColor" stroke-width="3"/></g></svg></div>

    <!-- Question label (inside card, above drawing) -->
    <div class="top-label" id="top-label">how well did you sleep?</div>

    <!-- Intro prompt (shown before drawing starts) -->
    <div class="intro-prompt" id="intro-prompt">use the slider to<br>describe your day</div>

    <!-- Bottom checkin bar -->
    <div class="checkin-bar" id="checkin-bar">

      <div class="checkin-moment active" id="moment-sleep" data-key="sleep">
        <div class="question-label">how well did you sleep?</div>
        <div class="slider-wrap" data-key="sleep" role="slider" tabindex="0"
             aria-label="How well did you sleep?" aria-orientation="horizontal" aria-valuemin="1" aria-valuemax="5" aria-valuenow="3" aria-valuetext="3, so-so">
          <div class="slider-readout" aria-hidden="true">
            <div class="slider-number">3</div>
            <div class="slider-word">so-so</div>
          </div>
          <div class="slider-track-container">
            <div class="slider-track"><div class="slider-fill"></div></div>
            <div class="slider-thumb"><svg viewBox="0 0 71 67"><use href="#joy-o-thumb"/></svg></div>
          </div>
        </div>
      </div>

      <div class="checkin-moment" id="moment-energy" data-key="energy">
        <div class="question-label">what's your energy<br>like today?</div>
        <div class="slider-wrap" data-key="energy" role="slider" tabindex="0"
             aria-label="What's your energy like today?" aria-orientation="horizontal" aria-valuemin="1" aria-valuemax="5" aria-valuenow="3" aria-valuetext="3, steady">
          <div class="slider-readout" aria-hidden="true">
            <div class="slider-number">3</div>
            <div class="slider-word">steady</div>
          </div>
          <div class="slider-track-container">
            <div class="slider-track"><div class="slider-fill"></div></div>
            <div class="slider-thumb"><svg viewBox="0 0 71 67"><use href="#joy-o-thumb"/></svg></div>
          </div>
        </div>
      </div>

      <div class="checkin-moment" id="moment-mood" data-key="mood">
        <div class="question-label">how's your mood?</div>
        <div class="slider-wrap" data-key="mood" role="slider" tabindex="0"
             aria-label="How's your mood?" aria-orientation="horizontal" aria-valuemin="1" aria-valuemax="5" aria-valuenow="3" aria-valuetext="3, okay">
          <div class="slider-readout" aria-hidden="true">
            <div class="slider-number">3</div>
            <div class="slider-word">okay</div>
          </div>
          <div class="slider-track-container">
            <div class="slider-track"><div class="slider-fill"></div></div>
            <div class="slider-thumb"><svg viewBox="0 0 71 67"><use href="#joy-o-thumb"/></svg></div>
          </div>
        </div>
      </div>

      <div class="checkin-moment" id="moment-stress" data-key="stress">
        <div class="question-label">how stressed are you feeling?</div>
        <div class="slider-wrap" data-key="stress" role="slider" tabindex="0"
             aria-label="How stressed are you feeling?" aria-orientation="horizontal" aria-valuemin="1" aria-valuemax="5" aria-valuenow="2" aria-valuetext="2, mild">
          <div class="slider-readout" aria-hidden="true">
            <div class="slider-number">2</div>
            <div class="slider-word">mild</div>
          </div>
          <div class="slider-track-container">
            <div class="slider-track"><div class="slider-fill"></div></div>
            <div class="slider-thumb"><svg viewBox="0 0 71 67"><use href="#joy-o-thumb"/></svg></div>
          </div>
        </div>
      </div>

      <div class="checkin-moment" id="moment-load" data-key="load">
        <div class="question-label">how full is your day?</div>
        <div class="slider-wrap" data-key="load" role="slider" tabindex="0"
             aria-label="How full is your day?" aria-orientation="horizontal" aria-valuemin="1" aria-valuemax="5" aria-valuenow="3" aria-valuetext="3, moderate">
          <div class="slider-readout" aria-hidden="true">
            <div class="slider-number">3</div>
            <div class="slider-word">moderate</div>
          </div>
          <div class="slider-track-container">
            <div class="slider-track"><div class="slider-fill"></div></div>
            <div class="slider-thumb"><svg viewBox="0 0 71 67"><use href="#joy-o-thumb"/></svg></div>
          </div>
        </div>
      </div>

      <div class="checkin-moment" id="moment-besttime" data-key="besttime">
        <div class="question-label">when do you feel sharpest?</div>
        <div class="slider-wrap" data-key="besttime" role="slider" tabindex="0"
             aria-label="When do you feel sharpest?" aria-orientation="horizontal" aria-valuemin="1" aria-valuemax="4" aria-valuenow="1" aria-valuetext="morning">
          <div class="slider-readout" aria-hidden="true">
            <div class="slider-number"></div>
            <div class="slider-word">morning</div>
          </div>
          <div class="slider-track-container">
            <div class="slider-track"><div class="slider-fill"></div></div>
            <div class="slider-thumb"><svg viewBox="0 0 71 67"><use href="#joy-o-thumb"/></svg></div>
          </div>
        </div>
      </div>

      <div class="checkin-progress" id="checkin-progress">
        <div class="progress-dot" data-idx="0"></div>
        <div class="progress-dot" data-idx="1"></div>
        <div class="progress-dot" data-idx="2"></div>
        <div class="progress-dot" data-idx="3"></div>
        <div class="progress-dot" data-idx="4"></div>
        <div class="progress-dot" data-idx="5"></div>
      </div>

    </div>

    <!-- Done actions (after all sliders) -->
    <div class="done-actions" id="done-actions">
      <button class="done-btn" id="export-btn" onclick="openShareSheet()">share</button>
      <button class="done-btn" onclick="startOver()">start over</button>
    </div>

    <!-- Reveal: text hugs the shape -->
    <div class="reveal-overlay" id="reveal-overlay">
      <div class="reveal-text-top">
        <div class="reveal-date" id="reveal-date"></div>
        <div class="reveal-capacity" id="reveal-capacity"></div>
        <div class="reveal-timing" id="reveal-timing"></div>
      </div>
      <div class="reveal-spacer"></div>
      <div class="reveal-text-bottom">
        <div class="reveal-nudge" id="reveal-nudge"></div>
      </div>
    </div>

    <div class="gif-progress" id="gif-progress"></div>
  </div>
</div>

<!-- Share sheet -->
<div class="share-backdrop" id="share-backdrop" onclick="closeShareSheet()"></div>
<div class="share-sheet" id="share-sheet">
  <div class="share-handle"></div>

  <button class="share-row" id="share-instagram" onclick="shareInstagram()">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="rgba(130,95,35,0.8)" stroke-width="1.5"><rect x="2" y="2" width="20" height="20" rx="5"/><circle cx="12" cy="12" r="5"/><circle cx="17.5" cy="6.5" r="1" fill="rgba(130,95,35,0.8)" stroke="none"/></svg>
    <span class="share-row-label">share to Instagram Stories</span>
    <svg class="share-row-chevron" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>
  </button>

  <button class="share-row" onclick="shareTwitter()">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="rgba(130,95,35,0.8)"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-4.714-6.231-5.401 6.231H2.742l7.733-8.835L1.254 2.25H8.08l4.26 5.632zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
    <span class="share-row-label">post to X</span>
    <svg class="share-row-chevron" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>
  </button>

  <button class="share-row" onclick="shareLinkedIn()">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="rgba(130,95,35,0.8)"><path d="M16 8a6 6 0 016 6v7h-4v-7a2 2 0 00-2-2 2 2 0 00-2 2v7h-4v-7a6 6 0 016-6zM2 9h4v12H2z"/><circle cx="4" cy="4" r="2"/></svg>
    <span class="share-row-label">share on LinkedIn</span>
    <svg class="share-row-chevron" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>
  </button>

  <button class="share-row" onclick="downloadCardPng()">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="rgba(130,95,35,0.8)" stroke-width="1.5"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
    <span class="share-row-label">save image</span>
    <svg class="share-row-chevron" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>
  </button>

  <div class="share-divider"></div>

  <button class="share-row" onclick="copyGlowText()">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="rgba(130,95,35,0.8)" stroke-width="1.5"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg>
    <span class="share-row-label" id="copy-glow-label">copy image</span>
    <svg class="share-row-chevron" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18l6-6-6-6"/></svg>
  </button>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════
let P = { sleep:3, energy:3, mood:3, stress:2, load:3, besttime:1 };
// Flow state
const MOMENTS = ['sleep','energy','mood','stress','load','besttime'];
let currentMoment = 0;
let answeredCount = 0;
let advancing = false;

// Sort state
let currentProfile = null;
let profileCode = '';
let categories = [];
let selectedCount = 0;
let dayLocked = false;

// ═══════════════════════════════════════════════════════════════
// PROFILE LOOKUP TABLE (v5 values)
// ═══════════════════════════════════════════════════════════════
const PROFILES = {
  A0: { name:'Embers',            descriptor:'Cup of tea, getting through it.',                           dw:0,   block:0,  picks:0, diff:'none',   tier:'A0' },
  A1: { name:'Candlelight',       descriptor:'Today\u2019s lit by candles.',                              dw:30,  block:45, picks:1, diff:'low',    tier:'A1' },
  B1: { name:'Slow Burn',         descriptor:'Tempting to burn it all at once.',                          dw:60,  block:60, picks:2, diff:'low',    tier:'B'  },
  B2: { name:'Drizzle',           descriptor:'Grey outside, cosy inside. Crack on.',                     dw:60,  block:60, picks:2, diff:'low',    tier:'B'  },
  B3: { name:'Friction',          descriptor:'System\u2019s strained. Hold steady.',                     dw:45,  block:45, picks:2, diff:'low',    tier:'B'  },
  B4: { name:'Tenterhooks',       descriptor:'Big day. Tank\u2019s low.',                                dw:55,  block:60, picks:2, diff:'medium', tier:'B'  },
  C1: { name:'Blue Sky Day',      descriptor:'Not a cloud in sight.',                                    dw:150, block:90, picks:3, diff:'medium', tier:'C'  },
  C2: { name:'Hungry',            descriptor:'Full plate. Big appetite.',                                dw:150, block:75, picks:3, diff:'medium', tier:'C'  },
  C3: { name:'Frenetic',          descriptor:'All revved up. Where to?',                                 dw:105, block:75, picks:3, diff:'medium', tier:'C'  },
  C4: { name:'Humming',           descriptor:'Everything, all at once.',                                 dw:120, block:75, picks:3, diff:'hard',   tier:'C'  },
  D1: { name:'Magic',             descriptor:'A rare one. Enjoy it!',                                    dw:180, block:90, picks:3, diff:'hard',   tier:'D'  },
  D2: { name:'Vooma',             descriptor:'Freewheeling downhill. No brakes.',                        dw:180, block:90, picks:4, diff:'hard',   tier:'D'  },
  D3: { name:'Sparky',            descriptor:'Bright. Might combust.',                                   dw:120, block:90, picks:3, diff:'hard',   tier:'D'  },
  D4: { name:'Too Hot To Handle', descriptor:'Recommended: welding gloves.',                             dw:150, block:90, picks:4, diff:'hard',   tier:'D'  },
};

// ═══════════════════════════════════════════════════════════════
// PROFILE PALETTES — each profile maps to 3 hex colours
// ═══════════════════════════════════════════════════════════════
const PROFILE_PALETTES = {
  A0: { primary:'#3D2B1F', secondary:'#1A1410', accent:'#7A3A1A' },
  A1: { primary:'#D4A050', secondary:'#C88A30', accent:'#F0C870' },
  B1: { primary:'#D4752A', secondary:'#B85C1A', accent:'#8B3A0F' },
  B2: { primary:'#A8B8C8', secondary:'#8898A8', accent:'#C8D4DC' },
  B3: { primary:'#B8762A', secondary:'#7A6A5A', accent:'#5A5A6A' },
  B4: { primary:'#C8CC7A', secondary:'#A8A85A', accent:'#D8D4A0' },
  C1: { primary:'#F5E040', secondary:'#F8C830', accent:'#FFFBE0' },
  C2: { primary:'#D45A2A', secondary:'#E8782A', accent:'#F0A050' },
  C3: { primary:'#C8E020', secondary:'#E8F040', accent:'#A0C010' },
  C4: { primary:'#E0802A', secondary:'#D86830', accent:'#C8A048' },
  D1: { primary:'#F0C030', secondary:'#E8A020', accent:'#A060C8' },
  D2: { primary:'#00E8D0', secondary:'#00C8F0', accent:'#80F0E0' },
  D3: { primary:'#F8F040', secondary:'#F8C020', accent:'#F06080' },
  D4: { primary:'#F03010', secondary:'#F87030', accent:'#F8A040' },
};

// ═══════════════════════════════════════════════════════════════
// SORT PROMPT (universal)
// ═══════════════════════════════════════════════════════════════
const SORT_PROMPT = 'What\u2019s on the cards today?';

// ═══════════════════════════════════════════════════════════════
// CATEGORIES + RECOMMENDATIONS
// All 7 categories always shown. Recommended ones are visually
// foregrounded and listed first. Non-recommended are fully available.
// No lock, no grey-out. The user is sovereign.
// ═══════════════════════════════════════════════════════════════
const CAT_NAMES = ['Deep Work','Movement','Connection','Growth','Creative Play','Admin','Rest'];

const RECOMMENDATIONS = {
  A0: { recommended: ['Rest'],                                                       rationale: null },
  A1: { recommended: ['Rest', 'Admin'],                                         rationale: 'It\u2019s a day to use kindly.' },
  B1: { recommended: ['Deep Work', 'Growth'],                                        rationale: 'It\u2019s a focus day.' },
  B2: { recommended: ['Admin', 'Connection'],                                   rationale: 'It\u2019s a hygge day.' },
  B3: { recommended: ['Deep Work', 'Admin'],                                    rationale: 'It\u2019s a day for getting one hard thing done.' },
  B4: { recommended: ['Admin', 'Rest'],                                         rationale: 'It\u2019s not an ideal day for deep focus.' },
  C1: { recommended: ['Deep Work', 'Creative Play', 'Growth'],                       rationale: 'It\u2019s a day for the things that only you can do.' },
  C2: { recommended: ['Deep Work', 'Growth', 'Creative Play'],                       rationale: 'It\u2019s a day for the ambitious stuff.' },
  C3: { recommended: ['Creative Play', 'Movement'],                                  rationale: 'It\u2019s an expressive or physical day.' },
  C4: { recommended: ['Deep Work', 'Growth', 'Admin'],                          rationale: 'It\u2019s a day for doing three things well.' },
  D1: { recommended: ['Deep Work', 'Creative Play', 'Growth', 'Connection'],         rationale: 'Rare day. It\u2019s a day to make the most of.' },
  D2: { recommended: ['Deep Work', 'Creative Play', 'Movement', 'Growth'],           rationale: 'It\u2019s a day where everything\u2019s on the cards.' },
  D3: { recommended: ['Creative Play', 'Deep Work', 'Movement'],                     rationale: 'It\u2019s a day to channel, before it channels you.' },
  D4: { recommended: ['Creative Play', 'Deep Work', 'Movement', 'Connection'],       rationale: 'It\u2019s a day where you can handle all of it.' },
};

// ═══════════════════════════════════════════════════════════════
// PROFILE DETECTION
// ═══════════════════════════════════════════════════════════════
function getProfile(params) {
  const { energy, mood, stress, load } = params;
  const ec = energy; // single energy value now
  let ae = Math.min(5, Math.max(1, ec + (mood - 3) * 0.25 + Math.max(0, (stress - 3)) * -0.5));
  if (stress === 5) ae = Math.min(ae, 3.99);

  // Determine tier
  let tier;
  if (ae < 1.5) tier = 'A0';
  else if (ae < 2.0) tier = 'A1';
  else if (ae < 3.0) tier = 'B';
  else if (ae < 4.0) tier = 'C';
  else tier = 'D';

  // For A0/A1 no quadrant needed
  if (tier === 'A0' || tier === 'A1') {
    profileCode = tier;
    currentProfile = PROFILES[tier];
    return currentProfile;
  }

  // Determine quadrant for B/C/D
  const stressHigh = stress >= 3;
  const loadHigh = load >= 3;
  let quad;
  if (!stressHigh && !loadHigh) quad = 1;       // LL
  else if (!stressHigh && loadHigh) quad = 2;    // LH
  else if (stressHigh && !loadHigh) quad = 3;    // HL
  else quad = 4;                                  // HH

  profileCode = tier + quad;
  currentProfile = PROFILES[profileCode];
  return currentProfile;
}

// ═══════════════════════════════════════════════════════════════
// CATEGORY SURFACING via RECOMMENDATIONS
// All categories always shown. Recommended ones get 'promoted'.
// ═══════════════════════════════════════════════════════════════
function getCategories(code, params) {
  const rec = RECOMMENDATIONS[code];
  if (!rec) return [];

  const recommended = new Set(rec.recommended || []);

  // Build category objects — recommended = promoted, rest = offered
  // A0 special case: Rest is auto-assigned, everything else offered
  categories = CAT_NAMES.map(name => {
    let status = 'offered';
    if (code === 'A0' && name === 'Rest') status = 'auto-assigned';
    else if (recommended.has(name)) status = 'promoted';
    return { name, status, selected: status === 'auto-assigned' };
  });

  // Sort: recommended first (preserving order within RECOMMENDATIONS.recommended),
  // then non-recommended in original CAT_NAMES order
  const recOrder = rec.recommended || [];
  categories.sort((a, b) => {
    const aRec = recOrder.indexOf(a.name);
    const bRec = recOrder.indexOf(b.name);
    const aIdx = aRec >= 0 ? aRec : 100 + CAT_NAMES.indexOf(a.name);
    const bIdx = bRec >= 0 ? bRec : 100 + CAT_NAMES.indexOf(b.name);
    return aIdx - bIdx;
  });

  return categories;
}

// ═══════════════════════════════════════════════════════════════
// WORD LABELS PER DIMENSION
// ═══════════════════════════════════════════════════════════════
const WORD_LABELS = {
  sleep:    ['', 'rough', 'restless', 'so-so', 'well', 'deep'],
  energy:   ['', 'empty', 'low', 'steady', 'charged', 'wired'],
  mood:     ['', 'down', 'off', 'okay', 'good', 'bright'],
  stress:   ['', 'calm', 'mild', 'moderate', 'tense', 'overwhelmed'],
  load:     ['', 'light', 'easy', 'moderate', 'busy', 'heavy'],
  besttime: ['', 'morning', 'midday', 'afternoon', 'evening']
};

// CHECKIN_COLORS kept for slider fill tints
const CHECKIN_COLORS = {
  sleep:    { hue: 260 },
  energy:   { hue: 48  },
  mood:     { hue: 210 },
  stress:   { hue: 10  },
  load:     { hue: 25  },
  besttime: { hue: 38  }
};

// ═══════════════════════════════════════════════════════════════
// FORMULA
// ═══════════════════════════════════════════════════════════════
const DW_LOOKUP={A1:{LL:30,LH:30,HL:30,HH:30},B:{LL:60,LH:60,HL:45,HH:55},C:{LL:150,LH:150,HL:105,HH:120},D:{LL:180,LH:180,HL:120,HH:150}};
const SLEEP_CEIL={1:0.55,2:0.70,3:0.82,4:0.93,5:1.00};

function calcDeepWork(sl,en,mo,st,lo){
  const ec=en;
  let ae=Math.min(5,Math.max(1,ec+(mo-3)*0.25+Math.max(0,(st-3))*-0.5));
  if(st===5)ae=Math.min(ae,3.99);
  if(ae<1.5)return 0;
  if(ae<2.0)return Math.round(30*SLEEP_CEIL[sl]);
  let tier,floor;
  if(ae<3.0){tier='B';floor=2;}else if(ae<4.0){tier='C';floor=3;}else{tier='D';floor=4;}
  const tp=ae-floor,sh=(st-1)/4,lh=(lo-1)/4;
  const qLL=(1-sh)*(1-lh),qLH=(1-sh)*lh,qHL=sh*(1-lh),qHH=sh*lh;
  const blend=tr=>{const l=DW_LOOKUP[tr];return qLL*l.LL+qLH*l.LH+qHL*l.HL+qHH*l.HH;};
  const pb=blend(tier),tiers=['B','C','D'],idx=tiers.indexOf(tier);
  let pw,sb;
  if(tp<0.5){pw=0.5+tp;sb=idx>0?blend(tiers[idx-1]):blend('A1');}
  else{pw=0.5+(1-tp);sb=idx<2?blend(tiers[idx+1]):pb;}
  return Math.min(180,Math.round((pw*pb+(1-pw)*sb)*SLEEP_CEIL[sl]));
}

function formatDW(m){if(m===0)return'0';const h=Math.floor(m/60),mm=m%60;if(h===0)return`${mm}m`;if(mm===0)return`${h}h`;return`${h}h${mm}`;}

function formatDeepFocusLine(mins, code) {
  if (code === 'A0') return null;
  const time = formatDW(mins);
  if (code === 'A1') return `Up to ${time} for deep focus, if the energy\u2019s there.`;
  return `${time} to go deep on what matters most.`;
}

// ═══════════════════════════════════════════════════════════════
// GLOW CAPACITY (reveal page formula)
// ═══════════════════════════════════════════════════════════════
function computeGlow(params) {
  const { energy, sleep, mood, stress, besttime } = params;

  // Step 1: Weighted composite (matches spreadsheet B16-B17)
  const baseCapacity = (0.30 * sleep) + (0.35 * energy) + (0.20 * mood) + (0.15 * (6 - stress));
  let capacityPct = ((baseCapacity - 1) / 4) * 100;

  // Step 2: Sleep ceiling (matches spreadsheet B18-B19)
  const sleepCeilings = { 1: 0.55, 2: 0.75, 3: 0.90, 4: 0.96, 5: 1.00 };
  capacityPct = capacityPct * sleepCeilings[sleep];

  // Step 3: Stress cap (matches spreadsheet B20)
  if (stress === 5) capacityPct = Math.min(capacityPct, 60);

  // Step 4: Round (matches spreadsheet B21 =ROUND(B20,0))
  capacityPct = Math.round(capacityPct);
  capacityPct = Math.max(0, Math.min(100, capacityPct));

  // Step 5: Deep work hours (matches spreadsheet B22-B23)
  const decimalHours = capacityPct / 100 * 3;
  const dh = Math.floor(decimalHours);
  let dm = Math.round(((decimalHours - dh) * 60) / 15) * 15;
  // Roll over if rounding pushes minutes to 60
  let finalH = dh, finalM = dm;
  if (dm >= 60) { finalH = dh + 1; finalM = 0; }
  // Under 1h: show "30m" not "0h 30m" (cleaner)
  let deepWork;
  if (finalH === 0) deepWork = `${finalM}m`;
  else if (finalM === 0) deepWork = `${finalH}h`;
  else deepWork = `${finalH}h ${String(finalM).padStart(2, '0')}m`;

  // B28: Capacity line
  const capacityLine = `You\u2019re at ${capacityPct}% today.`;

  // B29: Timing line (includes deep work hours)
  const timeLabels = { 1: 'morning', 2: 'midday', 3: 'afternoon', 4: 'evening' };
  const timeLabel = timeLabels[besttime] || 'morning';
  let timingLine;
  if (finalH === 0 && finalM === 0) {
    timingLine = 'Rest is your priority today.';
  } else {
    timingLine = `You\u2019ll be sharpest this ${timeLabel}. Aim for ${deepWork} of deep work.`;
  }

  // B30: Nudge line (capacity-specific bands)
  let nudgeLine;
  if (capacityPct >= 80)      nudgeLine = 'A good day to go after the things that matter.';
  else if (capacityPct >= 60) nudgeLine = 'Focus on what matters most.';
  else if (capacityPct >= 40) nudgeLine = 'One priority. Give it your best window.';
  else if (capacityPct >= 20) nudgeLine = 'Be kind to yourself today. One thing is enough.';
  else                        nudgeLine = 'Today is about getting through, not getting ahead.';

  return { capacityPct, capacityLine, timingLine, nudgeLine };
}

// ═══════════════════════════════════════════════════════════════
// DATE
// ═══════════════════════════════════════════════════════════════
const dateStr = new Date().toLocaleDateString('en-GB',{day:'numeric',month:'short',year:'numeric'}).toUpperCase();

// ═══════════════════════════════════════════════════════════════
// PROGRESS DOTS
// ═══════════════════════════════════════════════════════════════
function updateDots() {
  const dots = document.querySelectorAll('.progress-dot');
  dots.forEach((dot, i) => {
    dot.classList.remove('filled', 'current');
    if (i < answeredCount) dot.classList.add('filled');
    else if (i === currentMoment) dot.classList.add('current');
  });
}

// ═══════════════════════════════════════════════════════════════
// MOMENT TRANSITIONS
// ═══════════════════════════════════════════════════════════════
function showMoment(idx) {
  const moments = document.querySelectorAll('.checkin-moment');
  const current = document.querySelector('.checkin-moment.active');

  if (current) {
    current.classList.remove('active');
    current.classList.add('exit-up');
    current.addEventListener('animationend', function handler() {
      current.removeEventListener('animationend', handler);
      current.classList.remove('exit-up');
    }, { once: true });
  }

  currentMoment = idx;

  // Update top label
  const topLabel = document.getElementById('top-label');
  topLabel.classList.add('hidden');

  // Spirograph params update in real-time via slider handler

  setTimeout(() => {
    const next = moments[idx];
    next.classList.add('enter-up');
    next.classList.add('active');

    // Sync top label text
    const ql = next.querySelector('.question-label');
    if (ql) { topLabel.innerHTML = ql.innerHTML; }
    topLabel.classList.remove('hidden');
    // Force style recalc so animation starts cleanly
    void next.offsetWidth;

    next.addEventListener('animationend', function handler() {
      next.removeEventListener('animationend', handler);
      next.classList.remove('enter-up');
      advancing = false; // Unlock interaction only after animation completes
    }, { once: true });

    // Safety: if animationend never fires (e.g. reduced-motion), unlock after timeout
    setTimeout(() => { advancing = false; }, 500);

    // Reset slider to default value for this moment
    const wrap = next.querySelector('.slider-wrap');
    if (wrap) {
      const key = wrap.dataset.key;
      const val = P[key];
      updateSliderVisual(wrap, val);
    }

    updateDots();
  }, 250);
}

// ═══════════════════════════════════════════════════════════════
// SLIDER VISUAL UPDATE
// ═══════════════════════════════════════════════════════════════
function updateSliderVisual(wrap, value) {
  const key = wrap.dataset.key;
  const track = wrap.querySelector('.slider-track');
  const thumb = wrap.querySelector('.slider-thumb');
  const fill = wrap.querySelector('.slider-fill');
  const numEl = wrap.querySelector('.slider-number');
  const wordEl = wrap.querySelector('.slider-word');
  const trackW = track.getBoundingClientRect().width || 200;

  // besttime uses 1-4 range, others 1-5
  const maxVal = key === 'besttime' ? 4 : 5;
  const pct = (value - 1) / (maxVal - 1); // 0=left (1), 1=right (max)
  const leftPx = pct * trackW;

  thumb.style.left = leftPx + 'px';
  fill.style.width = (pct * 100) + '%';

  // Fill color from checkin color map
  const colorConfig = CHECKIN_COLORS[key];
  if (colorConfig) {
    fill.style.background = `hsla(${colorConfig.hue}, 30%, 55%, 0.10)`;
  }

  numEl.textContent = key === 'besttime' ? '' : value;
  const word = WORD_LABELS[key][value];
  wordEl.style.opacity = '0';
  setTimeout(() => {
    wordEl.textContent = word;
    wordEl.style.opacity = '1';
  }, 80);

  // Update ARIA
  wrap.setAttribute('aria-valuenow', value);
  wrap.setAttribute('aria-valuetext', key === 'besttime' ? word : `${value}, ${word}`);

  // Pop animation on number
  numEl.classList.add('pop');
  setTimeout(() => numEl.classList.remove('pop'), 250);
}

// ═══════════════════════════════════════════════════════════════
// SLIDER INTERACTION — Pointer events with velocity + spring snap
// ═══════════════════════════════════════════════════════════════
let activeSlider = null;
let activePointerId = null;
let pointerHistory = [];
let autoAdvanceTimer = null;

function initSliders() {
  document.querySelectorAll('.slider-wrap').forEach(wrap => {
    wrap.addEventListener('pointerdown', onSliderDown);
    wrap.addEventListener('keydown', onSliderKey);
  });
}

function onSliderKey(e) {
  if (advancing) return;
  const wrap = e.currentTarget;
  const key = wrap.dataset.key;
  const maxVal = key === 'besttime' ? 4 : 5;
  let val = P[key];

  switch (e.key) {
    case 'ArrowRight': case 'ArrowUp':   val = Math.min(maxVal, val + 1); break;
    case 'ArrowLeft':  case 'ArrowDown':  val = Math.max(1, val - 1);     break;
    case 'Home':                          val = 1;                         break;
    case 'End':                           val = maxVal;                    break;
    default: return;
  }
  e.preventDefault();

  // First key press: start spirograph
  if (!Spiro.running) {
    document.getElementById('intro-prompt').classList.add('hidden');
    spiroStart();
  }

  P[key] = val;
  updateSliderVisual(wrap, val);
  spiroRecalcTargets();

  // On first interaction, snap params
  if (!Spiro.hasBurst) {
    Spiro.hasBurst = true;
    Spiro.energy = Spiro.tEnergy;
    Spiro.mood = Spiro.tMood;
    Spiro.stress = Spiro.tStress;
    Spiro.sleep = Spiro.tSleep;
    Spiro.load = Spiro.tLoad;
  }

  // Auto-advance after key interaction (same as pointer)
  answeredCount = currentMoment + 1;
  updateDots();
  if (autoAdvanceTimer) clearTimeout(autoAdvanceTimer);
  autoAdvanceTimer = setTimeout(() => {
    advancing = true;
    if (currentMoment < MOMENTS.length - 1) {
      showMoment(currentMoment + 1);
    } else {
      showDoneState();
    }
  }, 1400);
}

function onSliderDown(e) {
  e.preventDefault(); // Must be first — prevents Safari scroll during transition dead zone

  if (advancing) return;

  // Only respond to the active moment's slider
  const moment = e.currentTarget.closest('.checkin-moment');
  if (!moment || !moment.classList.contains('active')) return;

  // Clear any pending auto-advance so slider isn't yanked away mid-drag
  if (autoAdvanceTimer) { clearTimeout(autoAdvanceTimer); autoAdvanceTimer = null; }

  // First touch: hide intro prompt, start spirograph
  if (!Spiro.running) {
    document.getElementById('intro-prompt').classList.add('hidden');
    spiroStart();
  }

  const wrap = e.currentTarget;
  activeSlider = wrap;
  activePointerId = e.pointerId;
  pointerHistory = [];

  // Document-level listeners — avoids iOS Safari setPointerCapture bugs
  document.addEventListener('pointermove', onSliderMove);
  document.addEventListener('pointerup', onSliderUp);
  document.addEventListener('pointercancel', onSliderUp);

  // Disable spring transition during drag + force style flush
  const thumb = wrap.querySelector('.slider-thumb');
  const fill = wrap.querySelector('.slider-fill');
  thumb.style.transition = 'none';
  fill.style.transition = 'none';
  thumb.offsetHeight;

  // Immediate move to tap position
  moveSliderToPointer(wrap, e);
}

function onSliderMove(e) {
  if (!activeSlider || e.pointerId !== activePointerId) return;
  e.preventDefault();
  pointerHistory.push({ x: e.clientX, t: Date.now() });
  if (pointerHistory.length > 5) pointerHistory.shift();
  moveSliderToPointer(activeSlider, e);
}

function onSliderUp(e) {
  if (!activeSlider) return;
  if (e.pointerId !== undefined && e.pointerId !== activePointerId) return;
  const wrap = activeSlider;
  activeSlider = null;
  activePointerId = null;

  document.removeEventListener('pointermove', onSliderMove);
  document.removeEventListener('pointerup', onSliderUp);
  document.removeEventListener('pointercancel', onSliderUp);

  // Re-enable spring transition (horizontal)
  const thumb = wrap.querySelector('.slider-thumb');
  const fill = wrap.querySelector('.slider-fill');
  thumb.style.transition = 'left 0.35s cubic-bezier(0.34,1.56,0.64,1)';
  fill.style.transition = 'width 0.35s cubic-bezier(0.34,1.56,0.64,1)';

  // Snap to nearest integer with velocity consideration
  const key = wrap.dataset.key;
  let snappedVal = P[key];

  // Check for flick velocity (horizontal)
  if (pointerHistory.length >= 2) {
    const last = pointerHistory[pointerHistory.length - 1];
    const prev = pointerHistory[Math.max(0, pointerHistory.length - 3)];
    const dt = last.t - prev.t;
    if (dt > 0 && dt < 200) {
      const vx = (last.x - prev.x) / dt; // px/ms, positive = right = higher
      if (Math.abs(vx) > 0.5) {
        const momentum = vx * 1.5; // positive = right = higher value
        const snapMax = key === 'besttime' ? 4 : 5;
        snappedVal = Math.round(Math.min(snapMax, Math.max(1, snappedVal + momentum)));
      }
    }
  }

  P[key] = snappedVal;
  updateSliderVisual(wrap, snappedVal);
  spiroRecalcTargets();

  // On first interaction, snap params so first curves use correct values
  if (!Spiro.hasBurst) {
    Spiro.hasBurst = true;
    Spiro.energy = Spiro.tEnergy;
    Spiro.mood = Spiro.tMood;
    Spiro.stress = Spiro.tStress;
    Spiro.sleep = Spiro.tSleep;
    Spiro.load = Spiro.tLoad;
  }

  // Auto-advance after snap
  answeredCount = currentMoment + 1;
  updateDots();

  if (autoAdvanceTimer) clearTimeout(autoAdvanceTimer);
  autoAdvanceTimer = setTimeout(() => {
    advancing = true;
    if (currentMoment < MOMENTS.length - 1) {
      showMoment(currentMoment + 1);
    } else {
      showDoneState();
    }
  }, 1400);
}

function moveSliderToPointer(wrap, e) {
  const track = wrap.querySelector('.slider-track');
  const thumb = wrap.querySelector('.slider-thumb');
  const fill = wrap.querySelector('.slider-fill');
  const numEl = wrap.querySelector('.slider-number');
  const wordEl = wrap.querySelector('.slider-word');
  const key = wrap.dataset.key;

  const rect = track.getBoundingClientRect();
  if (rect.width === 0) return;
  const relX = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
  const pct = relX / rect.width; // 0 = left (value 1), 1 = right (value max)

  // Continuous position during drag
  thumb.style.left = relX + 'px';
  fill.style.width = (pct * 100) + '%';

  // Fill color
  const colorConfig = CHECKIN_COLORS[key];
  if (colorConfig) {
    fill.style.background = `hsla(${colorConfig.hue}, 30%, 55%, 0.10)`;
  }

  // Derive snapped value for display (besttime uses 1-4 range)
  const maxVal = key === 'besttime' ? 4 : 5;
  const continuous = 1 + pct * (maxVal - 1);
  const snapped = Math.round(Math.min(maxVal, Math.max(1, continuous)));

  if (P[key] !== snapped) {
    P[key] = snapped;
    numEl.textContent = key === 'besttime' ? '' : snapped;
    const word = WORD_LABELS[key][snapped];
    wordEl.textContent = word;
    wrap.setAttribute('aria-valuenow', snapped);
    wrap.setAttribute('aria-valuetext', key === 'besttime' ? word : `${snapped}, ${word}`);
    numEl.classList.add('pop');
    setTimeout(() => numEl.classList.remove('pop'), 250);
    spiroRecalcTargets();
  }
}

// (Name submit removed — spirograph starts immediately)

// ═══════════════════════════════════════════════════════════════
// AMBIENT SOUND ENGINE — Endel × Amélie × Cinematic Orchestra
// ═══════════════════════════════════════════════════════════════
var SoundEngine = (function() {
  // Generative ambient trance (Endel) with film-score harmonic
  // beauty (Amélie, To Build A Home). NOT a piano arpeggiator —
  // individual tones drift in and out at random intervals over a
  // slowly evolving chord bed. Lightness from River Flows in You.
  //
  // Six layers:
  //   Sparkle  — bell-like tones with harmonic overtone, drifting in/out
  //   Ghost    — subliminal sparkles at the edge of hearing
  //   Pad      — 3 detuned voices per tone (chorus), slow bloom/fade
  //   Bass     — warm drone with organic vibrato
  //   Breath   — filtered white noise with slow amplitude LFO (wind/breath)
  //   FilterLFO — slow modulation of master lowpass cutoff (Endel movement)
  //
  // A minor / modal scale: warm, emotional, Amélie-adjacent.
  // All notes >= C4 (262 Hz) for phone speakers.
  // Chords use add9, sus4, and modal voicings for emotional pull.

  var SCALE = [60,62,64,65,67,69,71,72,74,76,77,79]; // Am extended: C4–G5

  // ── SONGS: 7 daily presets with richer harmony ─────────────
  // Chord voicings use add9, sus4, and open intervals for emotional pull.
  // Each song has 5-6 chords for longer harmonic journeys.
  // New params: breathGain, ghostGain, shimmerGain, lfoRate, lfoDepth,
  //             padDetune (cents spread for chorus), padVoices (2 or 3)
  var SONGS = [
    { name:'Comptine',
      chords:[
        [60,64,69,72,76],   // Am add9 (C E A C' E')
        [60,65,72,77],      // F add9 (C F C' F')
        [60,64,67,74],      // Am/G (C E G D')
        [62,67,71,74],      // G (D G B D')
        [60,65,69,72]       // Dm/A (C F A C')
      ],
      bass:57, sparkleMin:1400, sparkleMax:3200, chordDur:20000,
      sparkleGain:0.055, padGain:0.022, masterVol:0.32, filterCut:3200,
      bassGain:0.010, vibratoDepth:2.2, vibratoRate:0.09,
      breathGain:0.018, ghostGain:0.012, shimmerGain:0.018,
      lfoRate:0.06, lfoDepth:800, padDetune:8, padVoices:3 },
    { name:'First Light',
      chords:[
        [60,64,67,72],      // C (C E G C')
        [62,65,69,74],      // Dm9 (D F A D')
        [60,64,71,76],      // Am7 (C E B E')
        [65,69,72,77],      // F maj (F A C' F')
        [60,67,72,76],      // Csus4 (C G C' E')
        [62,67,71,74]       // G (D G B D')
      ],
      bass:60, sparkleMin:1200, sparkleMax:2800, chordDur:18000,
      sparkleGain:0.060, padGain:0.024, masterVol:0.34, filterCut:3800,
      bassGain:0.011, vibratoDepth:1.8, vibratoRate:0.08,
      breathGain:0.015, ghostGain:0.014, shimmerGain:0.020,
      lfoRate:0.07, lfoDepth:900, padDetune:6, padVoices:3 },
    { name:'Still River',
      chords:[
        [60,64,69,76],      // Am add9 wide (C E A E')
        [64,67,71,76],      // Em (E G B E')
        [60,65,72,77],      // F add9 (C F C' F')
        [60,64,67,72],      // C (C E G C')
        [62,65,69,74]       // Dm (D F A D')
      ],
      bass:64, sparkleMin:1600, sparkleMax:3600, chordDur:22000,
      sparkleGain:0.048, padGain:0.026, masterVol:0.30, filterCut:2600,
      bassGain:0.013, vibratoDepth:2.8, vibratoRate:0.06,
      breathGain:0.022, ghostGain:0.010, shimmerGain:0.015,
      lfoRate:0.04, lfoDepth:600, padDetune:10, padVoices:3 },
    { name:'Midweek',
      chords:[
        [60,65,69,72],      // Dm/A (C F A C')
        [60,64,67,74],      // C add9 (C E G D')
        [62,67,71,76],      // G/B (D G B E')
        [60,64,69,72,76],   // Am add9 (C E A C' E')
        [65,69,72,77]       // F (F A C' F')
      ],
      bass:65, sparkleMin:1300, sparkleMax:3000, chordDur:19000,
      sparkleGain:0.052, padGain:0.023, masterVol:0.31, filterCut:3000,
      bassGain:0.011, vibratoDepth:2.0, vibratoRate:0.10,
      breathGain:0.020, ghostGain:0.012, shimmerGain:0.018,
      lfoRate:0.055, lfoDepth:750, padDetune:7, padVoices:3 },
    { name:'Gathering',
      chords:[
        [60,64,69,72,76],   // Am add9 (C E A C' E')
        [62,65,71,74],      // Dm7 (D F B D')
        [60,67,72,76],      // Csus4 (C G C' E')
        [64,67,71,76],      // Em (E G B E')
        [60,65,69,72],      // Dm/A (C F A C')
        [62,67,71,74]       // G (D G B D')
      ],
      bass:57, sparkleMin:1100, sparkleMax:2600, chordDur:17000,
      sparkleGain:0.062, padGain:0.021, masterVol:0.34, filterCut:3600,
      bassGain:0.010, vibratoDepth:1.8, vibratoRate:0.08,
      breathGain:0.016, ghostGain:0.015, shimmerGain:0.022,
      lfoRate:0.07, lfoDepth:950, padDetune:6, padVoices:3 },
    { name:'Open Window',
      chords:[
        [60,64,67,72],      // C (C E G C')
        [60,64,69,76],      // Am wide (C E A E')
        [65,69,72,77],      // F (F A C' F')
        [60,67,72,74],      // C add9 (C G C' D')
        [62,67,71,74]       // G (D G B D')
      ],
      bass:60, sparkleMin:1200, sparkleMax:2800, chordDur:18000,
      sparkleGain:0.058, padGain:0.024, masterVol:0.33, filterCut:3500,
      bassGain:0.011, vibratoDepth:2.0, vibratoRate:0.09,
      breathGain:0.017, ghostGain:0.013, shimmerGain:0.020,
      lfoRate:0.06, lfoDepth:850, padDetune:7, padVoices:3 },
    { name:'Long Morning',
      chords:[
        [60,64,69,76],      // Am wide (C E A E')
        [60,65,72,77],      // F add9 (C F C' F')
        [62,65,69,74],      // Dm (D F A D')
        [64,67,71,76],      // Em (E G B E')
        [60,64,67,72],      // C (C E G C')
        [60,67,72,76]       // Csus4 resolve (C G C' E')
      ],
      bass:64, sparkleMin:1800, sparkleMax:4000, chordDur:24000,
      sparkleGain:0.045, padGain:0.028, masterVol:0.28, filterCut:2400,
      bassGain:0.014, vibratoDepth:3.2, vibratoRate:0.05,
      breathGain:0.025, ghostGain:0.010, shimmerGain:0.013,
      lfoRate:0.035, lfoDepth:500, padDetune:12, padVoices:3 }
  ];

  // Shared envelope shapes — define the "character"
  // Sparkle: gentle bloom (not a pop), long sustain tail, very long fade
  var SP_ATK = 0.12, SP_SUS = 1.4, SP_REL = 3.0;
  // Pad: glacial bloom, long hold, slow dissolve
  var PD_ATK = 5.0, PD_HOLD = 14, PD_REL = 7;
  // Ghost: even slower, almost subliminal
  var GH_ATK = 0.8, GH_SUS = 2.5, GH_REL = 4.5;

  var ctx, masterGain, filter, filterLFO, filterLFOGain;
  var sparkleTimer, chordTimer, ghostTimer, running = false, muted = false;
  var activePads = [], currentChord = 0;
  var pendingStart = false, pendingSong = null;

  // Mobile devices need louder output (phone speakers vs desktop monitors)
  var IS_MOB = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)
    || (navigator.maxTouchPoints > 1 && /Mac/.test(navigator.platform));

  function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }

  function track(osc, env, dur) {
    var ref = { osc: osc, env: env };
    activePads.push(ref);
    setTimeout(function() {
      var i = activePads.indexOf(ref);
      if (i > -1) activePads.splice(i, 1);
    }, (dur + 0.5) * 1000);
  }

  // ── Sparkle: bell-like tone with harmonic shimmer ─────────
  // Two oscillators per sparkle: fundamental (sine) + octave-above
  // harmonic (sine, quieter) creates a bell/chime quality.
  // Slight random detune on both for Endel phasing.
  function emitSparkle(midi, s) {
    if (!ctx || !running) return;
    var now = ctx.currentTime;
    var dur = SP_ATK + SP_SUS + SP_REL;
    // Each sparkle has its own dynamics (0.6-1.0x) — organic variation
    var dyn = 0.6 + Math.random() * 0.4;
    var g = Math.max(s.sparkleGain * dyn, 0.0001);
    var sg = Math.max(s.shimmerGain * dyn * 0.6, 0.0001);

    // Fundamental tone
    var osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(midiToFreq(midi), now);
    osc.detune.setValueAtTime((Math.random() - 0.5) * 8, now);

    var env = ctx.createGain();
    env.gain.setValueAtTime(0.0001, now);
    env.gain.exponentialRampToValueAtTime(g, now + SP_ATK);
    env.gain.exponentialRampToValueAtTime(Math.max(g * 0.35, 0.0001),
      now + SP_ATK + SP_SUS);
    env.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    osc.connect(env); env.connect(filter);
    osc.start(now); osc.stop(now + dur + 0.1);
    track(osc, env, dur);

    // Shimmer harmonic: octave above, quieter, slightly different timing
    // This creates the bell/chime quality — the "sparkle" in the sparkle
    var shimOsc = ctx.createOscillator();
    shimOsc.type = 'sine';
    shimOsc.frequency.setValueAtTime(midiToFreq(midi + 12), now);
    shimOsc.detune.setValueAtTime((Math.random() - 0.5) * 12, now);

    var shimEnv = ctx.createGain();
    var shimDelay = 0.04 + Math.random() * 0.06;
    shimEnv.gain.setValueAtTime(0.0001, now);
    shimEnv.gain.exponentialRampToValueAtTime(sg, now + SP_ATK + shimDelay);
    shimEnv.gain.exponentialRampToValueAtTime(Math.max(sg * 0.2, 0.0001),
      now + SP_ATK + SP_SUS * 0.7);
    shimEnv.gain.exponentialRampToValueAtTime(0.0001, now + dur * 0.85);
    shimOsc.connect(shimEnv); shimEnv.connect(filter);
    shimOsc.start(now); shimOsc.stop(now + dur + 0.1);
    track(shimOsc, shimEnv, dur);
  }

  // ── Ghost: subliminal tone at the edge of hearing ─────────
  // Very quiet, very slow sparkle-like tones that create
  // the "something is there" quality that pulls you in.
  function emitGhost(midi, s) {
    if (!ctx || !running) return;
    var now = ctx.currentTime;
    var dur = GH_ATK + GH_SUS + GH_REL;
    var g = Math.max(s.ghostGain * (0.4 + Math.random() * 0.3), 0.0001);

    var osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(midiToFreq(midi), now);
    // Wider detune for dreamy quality
    osc.detune.setValueAtTime((Math.random() - 0.5) * 16, now);
    // Slow pitch drift over the ghost's life — Endel quality
    osc.detune.linearRampToValueAtTime(
      (Math.random() - 0.5) * 20, now + dur * 0.8);

    var env = ctx.createGain();
    env.gain.setValueAtTime(0.0001, now);
    env.gain.exponentialRampToValueAtTime(g, now + GH_ATK);
    env.gain.exponentialRampToValueAtTime(Math.max(g * 0.5, 0.0001),
      now + GH_ATK + GH_SUS);
    env.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    osc.connect(env); env.connect(filter);
    osc.start(now); osc.stop(now + dur + 0.1);
    track(osc, env, dur);
  }

  // ── Pad: slow-bloom with chorus (detuned voices) ──────────
  // Multiple oscillators per note with slight detuning creates
  // warmth and width — the "strings" quality of Cinematic Orchestra.
  // Triangle wave mixed with sine for richer harmonics.
  function emitPad(midi, s) {
    if (!ctx || !running) return;
    var now = ctx.currentTime;
    var dur = PD_ATK + PD_HOLD + PD_REL;
    var g = Math.max(s.padGain, 0.0001);
    var voices = s.padVoices || 3;
    var detune = s.padDetune || 8;
    var perVoice = g / voices;

    var ii;
    for (ii = 0; ii < voices; ii++) {
      var osc = ctx.createOscillator();
      // Alternate sine and triangle for harmonic richness
      osc.type = (ii === 0) ? 'sine' : ((ii % 2 === 1) ? 'triangle' : 'sine');
      osc.frequency.setValueAtTime(midiToFreq(midi), now);
      // Spread voices: center, +detune, -detune
      var d = (ii === 0) ? 0 : ((ii % 2 === 1) ? detune : -detune);
      osc.detune.setValueAtTime(d, now);
      // Very slow drift on detune — organic movement
      osc.detune.linearRampToValueAtTime(
        d + (Math.random() - 0.5) * 4, now + PD_ATK + PD_HOLD);

      var vg = Math.max(perVoice * (ii === 0 ? 1.0 : 0.6), 0.0001);
      var env = ctx.createGain();
      env.gain.setValueAtTime(0.0001, now);
      env.gain.exponentialRampToValueAtTime(vg, now + PD_ATK);
      env.gain.setValueAtTime(vg, now + PD_ATK + 0.1);
      env.gain.exponentialRampToValueAtTime(Math.max(vg * 0.6, 0.0001),
        now + PD_ATK + PD_HOLD);
      env.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      osc.connect(env); env.connect(filter);
      osc.start(now); osc.stop(now + dur + 0.1);
      track(osc, env, dur);
    }
  }

  // ── Sparkle scheduler: random timing, random notes ────────
  function startSparkles(s) {
    function spark() {
      if (!running) return;
      var chord = s.chords[currentChord];
      var note;
      // 70% chord tone (consonant), 20% scale tone (colour), 10% octave above chord tone
      var roll = Math.random();
      if (roll < 0.10) {
        // Octave-transposed chord tone — creates height and space
        note = chord[Math.floor(Math.random() * chord.length)] + 12;
        if (note > 84) note -= 12; // cap at C6
      } else if (roll < 0.30) {
        note = SCALE[Math.floor(Math.random() * SCALE.length)];
      } else {
        note = chord[Math.floor(Math.random() * chord.length)];
      }
      emitSparkle(note, s);
      var wait = s.sparkleMin + Math.random() * (s.sparkleMax - s.sparkleMin);
      sparkleTimer = setTimeout(spark, wait);
    }
    sparkleTimer = setTimeout(spark, 800);
  }

  // ── Ghost scheduler: slower, rarer, subliminal ────────────
  function startGhosts(s) {
    function ghost() {
      if (!running) return;
      var chord = s.chords[currentChord];
      // Ghost notes from chord tones only — always consonant
      var note = chord[Math.floor(Math.random() * chord.length)];
      // Occasional octave shift for depth
      if (Math.random() < 0.3) note += 12;
      if (note > 84) note -= 12;
      emitGhost(note, s);
      // Ghosts are rarer: 3-7 seconds apart
      var wait = 3000 + Math.random() * 4000;
      ghostTimer = setTimeout(ghost, wait);
    }
    ghostTimer = setTimeout(ghost, 2000);
  }

  // ── Chord scheduler: emit pads, advance harmony ───────────
  function startChords(s) {
    function next() {
      if (!running) return;
      var chord = s.chords[currentChord];
      // 3 pad tones: root, middle, and upper voice
      emitPad(chord[0], s);
      emitPad(chord[Math.floor(chord.length / 2)], s);
      if (chord.length > 3) {
        emitPad(chord[chord.length - 1], s);
      }
      chordTimer = setTimeout(function() {
        currentChord = (currentChord + 1) % s.chords.length;
        next();
      }, s.chordDur);
    }
    next();
  }

  // ── Breath noise: filtered white noise with slow LFO ──────
  // Creates organic wind/breath texture — the "nature" layer.
  // Bandpass-filtered noise with slow amplitude modulation.
  function startBreath(s) {
    if (!ctx || !running) return;
    var now = ctx.currentTime;
    // Create white noise buffer (2 seconds, looped)
    var bufLen = ctx.sampleRate * 2;
    var buf = ctx.createBuffer(1, bufLen, ctx.sampleRate);
    var data = buf.getChannelData(0);
    var jj;
    for (jj = 0; jj < bufLen; jj++) {
      data[jj] = (Math.random() * 2 - 1);
    }

    var noise = ctx.createBufferSource();
    noise.buffer = buf;
    noise.loop = true;

    // Bandpass filter: narrow band for wind character
    var bp = ctx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.setValueAtTime(800, now);
    bp.Q.setValueAtTime(1.2, now);
    // Very slow filter frequency drift — breathing quality
    var breathCycle = 8 + Math.random() * 4; // 8-12 second cycle
    var filterLow = 500;
    var filterHigh = 1200;
    // Schedule several cycles of filter movement
    var t = now;
    var kk;
    for (kk = 0; kk < 30; kk++) {
      bp.frequency.linearRampToValueAtTime(filterHigh, t + breathCycle * 0.5);
      bp.frequency.linearRampToValueAtTime(filterLow, t + breathCycle);
      t += breathCycle;
    }

    // Amplitude envelope: slow fade in, then LFO modulation
    var breathEnv = ctx.createGain();
    var bg = Math.max(s.breathGain, 0.0001);
    breathEnv.gain.setValueAtTime(0.0001, now);
    breathEnv.gain.linearRampToValueAtTime(bg, now + 8);

    // Amplitude LFO: very slow breathing rhythm
    var breathLFO = ctx.createOscillator();
    breathLFO.type = 'sine';
    breathLFO.frequency.setValueAtTime(0.08 + Math.random() * 0.04, now); // ~0.08-0.12 Hz
    var breathLFOGain = ctx.createGain();
    breathLFOGain.gain.setValueAtTime(bg * 0.5, now);

    breathLFO.connect(breathLFOGain);
    breathLFOGain.connect(breathEnv.gain);

    noise.connect(bp);
    bp.connect(breathEnv);
    breathEnv.connect(filter);

    noise.start(now);
    breathLFO.start(now);

    activePads.push({ osc: noise, env: breathEnv });
    activePads.push({ osc: breathLFO, env: breathLFOGain });
  }

  function hardStop() {
    running = false;
    pendingStart = false;
    pendingSong = null;
    if (sparkleTimer) { clearTimeout(sparkleTimer); sparkleTimer = null; }
    if (chordTimer) { clearTimeout(chordTimer); chordTimer = null; }
    if (ghostTimer) { clearTimeout(ghostTimer); ghostTimer = null; }
    activePads.forEach(function(p) {
      try { if (p.osc) p.osc.stop(); } catch(e) {}
      try { if (p.env) p.env.disconnect(); } catch(e) {}
    });
    activePads = [];
    if (filterLFO) { try { filterLFO.stop(); } catch(e) {} filterLFO = null; }
    if (filterLFOGain) { try { filterLFOGain.disconnect(); } catch(e) {} filterLFOGain = null; }
    if (filter) { filter.disconnect(); filter = null; }
    if (masterGain) { masterGain.disconnect(); masterGain = null; }
  }

  // ── iOS audio unlock + pending launch ────────────────────
  // Simplest possible approach: on every touchend/pointerup/click,
  // if launch is pending, create a fresh AudioContext in this
  // gesture and launch immediately. No Promises, no guards.
  var audioUnlocked = false;

  function kickAudio() {
    try { document.getElementById('audio-kick').play(); } catch(e) {}
  }

  function dbg(code) {
    var el = document.getElementById('sound-toggle');
    if (el) el.setAttribute('data-dbg', code);
  }

  function unlock(e) {
    try { kickAudio(); } catch(x) {}

    // Skip events that are NOT valid user activations on iOS
    if (e.type === 'touchstart') return;
    if (e.type === 'pointerdown') return; // never valid for touch on iOS
    // Valid events reaching here: touchend, pointerup, mousedown, click

    if (!pendingStart || running) return;

    dbg('U');  // unlock attempt

    try {
      // Abandon old ctx (don't close — close() is async and unreliable)
      ctx = null;

      // Create brand new AudioContext in this valid gesture
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      dbg('C');  // ctx created

      // Resume — might be sync or async, doesn't matter
      ctx.resume();

      // Play a short non-silent buffer to force audio session active
      var b = ctx.createBuffer(1, 44100, ctx.sampleRate);
      var ch = b.getChannelData(0);
      for (var i = 0; i < ch.length; i++) {
        ch[i] = Math.sin(i * 0.1) * 0.001; // barely-audible sine
      }
      var src = ctx.createBufferSource();
      src.buffer = b; src.connect(ctx.destination); src.start();

      // Launch NOW — don't wait for Promise/state/anything
      pendingStart = false;
      audioUnlocked = true;
      dbg('L');  // launched
      launch(pendingSong);
    } catch(ex) {
      dbg('E');  // error
    }
  }

  ['touchend','pointerup','mousedown','click'].forEach(function(evt) {
    document.addEventListener(evt, unlock, true);
  });

  function launch(s) {
    running = true;
    currentChord = 0;
    var now = ctx.currentTime;

    masterGain = ctx.createGain();
    masterGain.gain.setValueAtTime(0, now);
    // Slower fade-in (4s) for more gentle entry
    masterGain.gain.linearRampToValueAtTime(muted ? 0 : s.masterVol, now + 4);
    masterGain.connect(ctx.destination);

    filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(s.filterCut, now);
    filter.Q.setValueAtTime(0.7, now); // Slight resonance for warmth
    filter.connect(masterGain);

    // ── Filter LFO: slow modulation of cutoff frequency ─────
    // This is the "breathing" quality of Endel — the filter opens
    // and closes very slowly, making the texture feel alive.
    filterLFO = ctx.createOscillator();
    filterLFO.type = 'sine';
    filterLFO.frequency.setValueAtTime(s.lfoRate || 0.06, now);
    filterLFOGain = ctx.createGain();
    filterLFOGain.gain.setValueAtTime(0, now);
    // Slowly ramp in the LFO depth so it doesn't start abruptly
    filterLFOGain.gain.linearRampToValueAtTime(s.lfoDepth || 800, now + 10);
    filterLFO.connect(filterLFOGain);
    filterLFOGain.connect(filter.frequency);
    filterLFO.start(now);

    // ── Bass: warm drone with organic vibrato ───────────────
    // Two bass oscillators: sine fundamental + triangle one octave
    // above at lower volume, for harmonic richness through the lowpass.
    var bass = ctx.createOscillator();
    bass.type = 'sine';
    bass.frequency.setValueAtTime(midiToFreq(s.bass), now);
    var bassEnv = ctx.createGain();
    bassEnv.gain.setValueAtTime(0, now);
    bassEnv.gain.linearRampToValueAtTime(s.bassGain, now + 8);
    bass.connect(bassEnv); bassEnv.connect(filter);
    bass.start(now);
    activePads.push({ osc: bass, env: bassEnv });

    // Bass harmonic: octave above, triangle, quieter — adds warmth
    var bassHarm = ctx.createOscillator();
    bassHarm.type = 'triangle';
    bassHarm.frequency.setValueAtTime(midiToFreq(s.bass + 12), now);
    var bassHarmEnv = ctx.createGain();
    bassHarmEnv.gain.setValueAtTime(0, now);
    bassHarmEnv.gain.linearRampToValueAtTime(s.bassGain * 0.35, now + 10);
    bassHarm.connect(bassHarmEnv); bassHarmEnv.connect(filter);
    bassHarm.start(now);
    activePads.push({ osc: bassHarm, env: bassHarmEnv });

    // Bass vibrato — organic pitch wobble
    var vib = ctx.createOscillator();
    vib.type = 'sine';
    vib.frequency.setValueAtTime(s.vibratoRate, now);
    var vibG = ctx.createGain();
    vibG.gain.setValueAtTime(s.vibratoDepth, now);
    vib.connect(vibG); vibG.connect(bass.detune);
    vib.start(now);
    activePads.push({ osc: vib, env: vibG });

    // ── Start all layers ────────────────────────────────────
    startSparkles(s);
    startGhosts(s);
    startChords(s);
    startBreath(s);
  }

  return {
    start: function() {
      if (running || pendingStart) return;
      if (masterGain) hardStop();

      var song = SONGS[new Date().getDay()];
      // Mobile: boost volume 2.5× for phone speakers
      if (IS_MOB) {
        song = {};
        var orig = SONGS[new Date().getDay()];
        for (var k in orig) song[k] = orig[k];
        song.masterVol = Math.min(orig.masterVol * 2.5, 1.0);
      }

      // Set pending — unlock() on touchend/mousedown will handle it.
      // Don't create AudioContext here (pointerdown is not a valid
      // user activation on iOS touch, and even if ctx.state reports
      // 'running' it may be tainted and produce no output).
      pendingStart = true;
      pendingSong = song;
      dbg('P');  // pending
    },

    stop: function() {
      running = false;
      if (sparkleTimer) { clearTimeout(sparkleTimer); sparkleTimer = null; }
      if (chordTimer) { clearTimeout(chordTimer); chordTimer = null; }
      if (ghostTimer) { clearTimeout(ghostTimer); ghostTimer = null; }
      if (masterGain && ctx) {
        var now = ctx.currentTime;
        masterGain.gain.cancelScheduledValues(now);
        masterGain.gain.setValueAtTime(masterGain.gain.value, now);
        masterGain.gain.linearRampToValueAtTime(0, now + 4);
        activePads.forEach(function(p) {
          if (p.env && p.env.gain) {
            try {
              p.env.gain.cancelScheduledValues(now);
              p.env.gain.setValueAtTime(p.env.gain.value, now);
              p.env.gain.linearRampToValueAtTime(0, now + 4);
            } catch(e) {}
          }
        });
        setTimeout(function() {
          activePads.forEach(function(p) {
            try { if (p.osc) p.osc.stop(); } catch(e) {}
            try { if (p.env) p.env.disconnect(); } catch(e) {}
          });
          activePads = [];
          if (filterLFO) { try { filterLFO.stop(); } catch(e) {} filterLFO = null; }
          if (filterLFOGain) { try { filterLFOGain.disconnect(); } catch(e) {} filterLFOGain = null; }
          if (filter) { filter.disconnect(); filter = null; }
          if (masterGain) { masterGain.disconnect(); masterGain = null; }
        }, 4500);
      }
    },

    toggleMute: function() {
      muted = !muted;
      if (masterGain && ctx) {
        var now = ctx.currentTime;
        var s = SONGS[new Date().getDay()];
        var vol = IS_MOB ? Math.min(s.masterVol * 2.5, 1.0) : s.masterVol;
        masterGain.gain.cancelScheduledValues(now);
        masterGain.gain.setValueAtTime(masterGain.gain.value, now);
        masterGain.gain.linearRampToValueAtTime(muted ? 0 : vol, now + 0.5);
      }
      return muted;
    },

    get muted() { return muted; }
  };
})();

// ═══════════════════════════════════════════════════════════════
// DONE STATE — after all sliders answered
// ═══════════════════════════════════════════════════════════════
function showDoneState() {
  answeredCount = MOMENTS.length;
  updateDots();

  // Compute profile silently
  getProfile(P);
  getCategories(profileCode, P);

  // Compute glow capacity
  const glow = computeGlow(P);

  // Populate reveal overlay (matches Daily Calculator B28-B30)
  document.getElementById('reveal-date').textContent = dateStr;
  document.getElementById('reveal-capacity').textContent = glow.capacityLine;
  // Split two-sentence lines onto separate lines (better copywriting)
  document.getElementById('reveal-timing').innerHTML = glow.timingLine.replace(/\. (?=[A-Z])/g, '.<br>');
  document.getElementById('reveal-nudge').innerHTML = glow.nudgeLine.replace(/\. (?=[A-Z])/g, '.<br>');

  // Hide checkin bar, top label, and logo for reveal
  document.getElementById('checkin-bar').classList.add('hidden');
  document.getElementById('top-label').classList.add('hidden');
  document.getElementById('joy-logo').classList.add('hidden');

  // Show reveal (staggered fade-in via CSS animation-delay)
  setTimeout(() => {
    document.getElementById('reveal-overlay').classList.add('visible');
  }, 400);

  // Show done actions after reveal content has arrived
  setTimeout(() => {
    document.getElementById('done-actions').classList.add('visible');
  }, 2200);
}

// (Pre-reveal and card tap removed — spirograph is always visible)

// ═══════════════════════════════════════════════════════════════
// START OVER
// ═══════════════════════════════════════════════════════════════
function startOver() {
  // Fade out ambient sound
  SoundEngine.stop();
  document.getElementById('sound-toggle').classList.remove('visible', 'muted');

  // Clear any pending auto-advance timer
  if (autoAdvanceTimer) { clearTimeout(autoAdvanceTimer); autoAdvanceTimer = null; }

  // Stop and reset spirograph
  Spiro.running = false;
  spiroReset();

  // Show intro prompt again, reset time glow
  document.getElementById('intro-prompt').classList.remove('hidden');

  // Hide done actions and reveal overlay
  document.getElementById('done-actions').classList.remove('visible');
  // Hide and reset reveal
  const revealEl = document.getElementById('reveal-overlay');
  revealEl.classList.remove('visible');
  revealEl.querySelectorAll('.reveal-date, .reveal-capacity, .reveal-timing, .reveal-nudge').forEach(el => {
    el.style.animation = 'none';
    el.offsetHeight;
    el.style.animation = '';
  });

  // Reset parameters
  P = { sleep:3, energy:3, mood:3, stress:2, load:3, besttime:1 };
  answeredCount = 0;
  currentMoment = 0;
  advancing = false;
  dayLocked = false;

  // Reset moments
  document.querySelectorAll('.checkin-moment').forEach(m => m.classList.remove('active', 'exit-up', 'enter-up'));

  // Show checkin bar, top label, and first question
  const checkinBar = document.getElementById('checkin-bar');
  checkinBar.classList.remove('hidden');
  const topLabel = document.getElementById('top-label');
  topLabel.innerHTML = 'how well did you sleep?';
  topLabel.classList.remove('hidden');
  document.getElementById('joy-logo').classList.remove('hidden');
  document.getElementById('joy-logo').style.color = '';
  document.getElementById('moment-sleep').classList.add('active');
  document.getElementById('checkin-progress').classList.add('visible');
  updateDots();

  // Reset sliders to default
  document.querySelectorAll('.slider-wrap').forEach(wrap => {
    const key = wrap.dataset.key;
    updateSliderVisual(wrap, P[key]);
  });
}

// ═══════════════════════════════════════════════════════════════
// CANVAS SETUP
// ═══════════════════════════════════════════════════════════════
const orbCanvas = document.getElementById('orb-canvas'), orbCtx = orbCanvas.getContext('2d');

function sizeOrbCanvas() {
  const card = document.getElementById('card');
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const newW = Math.round(card.offsetWidth * dpr);
  const newH = Math.round(card.offsetHeight * dpr);
  if (newW === orbCanvas.width && newH === orbCanvas.height) return;

  // Save existing bitmap before resize (setting .width/.height clears it)
  let saved = null;
  if (orbCanvas.width > 0 && orbCanvas.height > 0) {
    try {
      saved = orbCtx.getImageData(0, 0, orbCanvas.width, orbCanvas.height);
    } catch (_) {}
  }

  const oldW = orbCanvas.width, oldH = orbCanvas.height;
  orbCanvas.width = newW;
  orbCanvas.height = newH;

  // Re-fill cream background
  orbCtx.fillStyle = 'hsl(38, 30%, 93%)';
  orbCtx.fillRect(0, 0, newW, newH);

  // Redraw saved bitmap scaled to new dimensions
  if (saved) {
    const tmp = document.createElement('canvas');
    tmp.width = oldW; tmp.height = oldH;
    tmp.getContext('2d').putImageData(saved, 0, 0);
    orbCtx.drawImage(tmp, 0, 0, newW, newH);
  }

  // Reset prevPoint — old coordinates are stale at new canvas size
  Spiro.prevPoint = null;
}

// ═══════════════════════════════════════════════════════════════
// TIME-OF-DAY GLOW — besttime changes card background tint
// 1=morning (warm peach), 2=midday (bright warm), 3=afternoon (golden),
// 4=evening (dusky blue-violet)
// ═══════════════════════════════════════════════════════════════
function updateTimeGlow() {
  // Time-of-day glow removed
}

// ═══════════════════════════════════════════════════════════════
// REDUCED MOTION
// ═══════════════════════════════════════════════════════════════
const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
let reducedMotion = prefersReducedMotion.matches;
prefersReducedMotion.addEventListener('change', e => { reducedMotion = e.matches; });

// ═══════════════════════════════════════════════════════════════
// SPIROGRAPH ENGINE
// Hypotrochoid + multi-arm epicycles, driven by slider state P.
// Lines accumulate on canvas (no clear) — the user creates their
// own visual mirror as they answer each question.
// ═══════════════════════════════════════════════════════════════
const Spiro = {
  t: 0,
  prevPoint: null,
  segmentCount: 0,   // tracks drawn segments for fade-in
  running: false,
  hasBurst: false,
  fillPhase: false,  // true during post-slider accelerated fill
  fillFrames: 0,     // frames remaining in fill phase
  fillTotal: 240,    // total fill frames (4 seconds at 60fps)
  // Current params (lerp toward targets)
  energy: 0.5,
  mood: 0.5,
  stress: 0.15,
  sleep: 0.4,
  load: 0.5,
  // Target params (set immediately on slider change)
  tEnergy: 0.5,
  tMood: 0.5,
  tStress: 0.15,
  tSleep: 0.4,
  tLoad: 0.5,
};

function spiroRecalcTargets() {
  // Energy 1-5 → 0-1
  Spiro.tEnergy = (P.energy - 1) / 4;
  // Mood 1-5 → 0-1
  Spiro.tMood = (P.mood - 1) / 4;
  // Stress 1-5 → 0-1
  Spiro.tStress = (P.stress - 1) / 4;
  // Sleep 1-5 → 0-1
  Spiro.tSleep = (P.sleep - 1) / 4;
  // Load 1-5 → 0-1 (controls brightness/intensity)
  Spiro.tLoad = (P.load - 1) / 4;
  // Update time-of-day glow if besttime changed
  updateTimeGlow();
}

// ── Geometric harmonograph engine ──
// Counter-rotating circles + load harmonic: organic flowing rosettes.
// Irrational frequency ratios (√2, √7 based) ensure the pattern never closes
// into a recognisable polygon or star shape at any drawing duration.
// Sleep → clarity/scatter, Energy → scale/speed, Mood → colour+elongation, Stress → tremor/breathing, Load → complexity+weight.

function spiroComputePoint(t) {
  const m = Spiro.mood;
  const st = Spiro.stress;
  const l = Spiro.load;

  // Irrational frequency offsets — pattern never closes, no integer-petal stars
  const f1 = 1.0;                           // circle 1: counterclockwise
  const f2 = 1.0 + Math.SQRT2 * 0.02;      // ≈1.02828, irrational detuning

  // MOOD → elongation (tight angular ↔ open round)
  // Reduced spread keeps shapes organic — lobes are rounded, not star-pointed
  const A1 = 0.56 + m * 0.09;        // 0.56→0.65
  const A2 = 0.44 - m * 0.09;        // 0.44→0.35

  // MOOD → phase (keeps pattern variety)
  const phase = Math.PI * (0.15 + m * 0.7);

  // STRESS → amplitude breathing (geometric density bands)
  // High stress = visible pulsation, calm = smooth uniform curves
  const breathe = reducedMotion ? 1.0 : 1.0 + st * 0.15 * Math.sin(0.12 * t);

  // Main pattern: Circle 1 CCW + Circle 2 CW
  let x = (A1 * Math.cos(f1 * t + phase) + A2 * Math.cos(f2 * t)) * breathe;
  let y = (A1 * Math.sin(f1 * t + phase) - A2 * Math.sin(f2 * t)) * breathe;

  // LOAD → secondary harmonic (pattern complexity)
  // √7 ≈ 2.646 — irrational, avoids 3-fold or any integer-fold symmetry
  const A3 = l * 0.04;               // 0→0.04
  const f3 = Math.sqrt(7);           // ≈2.6458, no integer resonance
  x += A3 * Math.cos(f3 * t);
  y -= A3 * Math.sin(f3 * t);

  const norm = A1 + A2 + A3;
  return { x: x / norm, y: y / norm };
}

function spiroFrame() {
  if (!Spiro.running) return;

  const W = orbCanvas.width, H = orbCanvas.height;
  if (W === 0 || H === 0) { requestAnimationFrame(spiroFrame); return; }

  // Slow lerp — shape evolves gradually from wherever it is, no jerking
  // ~3 seconds to reach 87% of new value (like physical pendulum inertia)
  const lerpRate = 0.01;
  Spiro.energy += (Spiro.tEnergy - Spiro.energy) * lerpRate;
  Spiro.mood += (Spiro.tMood - Spiro.mood) * lerpRate;
  Spiro.stress += (Spiro.tStress - Spiro.stress) * lerpRate;
  Spiro.sleep += (Spiro.tSleep - Spiro.sleep) * lerpRate;
  Spiro.load += (Spiro.tLoad - Spiro.load) * lerpRate;

  const cx = W / 2, cy = H * 0.52;

  // ENERGY → scale (small contained ↔ large expansive)
  const scale = Math.min(W, H) * (0.22 + Spiro.energy * 0.14);  // 0.22→0.36

  // ENERGY → drawing speed (reduced if user prefers less motion)
  const baseStep = 0.05 + Spiro.energy * 0.09;   // 0.05→0.14
  const isDrawing = activeSlider !== null;
  const motionMul = reducedMotion ? 0.3 : 1.0;
  const step = (isDrawing ? baseStep * 2.5 : baseStep * 0.6) * motionMul;
  const subSteps = Math.max(20, Math.round(step * 120));

  // MOOD → stroke colour (cool charcoal ↔ warm gold)
  const r = Math.round(50 + Spiro.mood * 95);    // 50→145
  const g = Math.round(45 + Spiro.mood * 65);    // 45→110
  const b = Math.round(42 - Spiro.mood * 2);     // 42→40

  // SLEEP → alpha + line width base
  const alpha = 0.15 + Spiro.sleep * 0.25;       // 0.15→0.40
  const sleepLineW = 0.45 + Spiro.sleep * 0.25;  // 0.45→0.70

  // LOAD → stroke weight bonus (light day = fine lines, heavy day = bold strokes)
  const loadLineW = Spiro.load * 0.50;            // 0→0.50
  const lineW = sleepLineW + loadLineW;

  // STRESS → smooth tremor amplitude (disabled under reduced motion)
  // Suppressed on final slider (load) so the interaction ends with clean lines
  const onLoadSlider = currentMoment >= MOMENTS.length - 1;
  const stressAmp = (reducedMotion || onLoadSlider) ? 0 : Spiro.stress * 1.0;

  // SLEEP → smooth scatter amplitude (disabled under reduced motion)
  const scatterAmp = (reducedMotion || onLoadSlider) ? 0 : (1.0 - Spiro.sleep) * 0.8;

  orbCtx.save();
  orbCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(3)})`;
  orbCtx.lineWidth = lineW;
  orbCtx.lineCap = 'round';
  orbCtx.lineJoin = 'round';

  for (let s = 0; s < subSteps; s++) {
    Spiro.t += step / subSteps;

    const pt = spiroComputePoint(Spiro.t);
    let x = cx + pt.x * scale;
    let y = cy + pt.y * scale;

    // Stress tremor — smooth high-frequency wobble (coprime to drawing freqs)
    const tremorX = Math.sin(Spiro.t * 47) * stressAmp;
    const tremorY = Math.cos(Spiro.t * 53) * stressAmp;

    // Sleep scatter — slow smooth drift, not per-point noise
    const scatterX = Math.sin(Spiro.t * 3.7) * scatterAmp;
    const scatterY = Math.cos(Spiro.t * 4.3) * scatterAmp;

    x += tremorX + scatterX;
    y += tremorY + scatterY;

    if (Spiro.prevPoint) {
      // Fade in first 50 segments — no visible start point
      if (Spiro.segmentCount < 50) {
        const segAlpha = alpha * (Spiro.segmentCount / 50);
        orbCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${segAlpha.toFixed(3)})`;
      }

      orbCtx.beginPath();
      orbCtx.moveTo(Spiro.prevPoint.x, Spiro.prevPoint.y);
      orbCtx.lineTo(x, y);
      orbCtx.stroke();
      Spiro.segmentCount++;

      // Restore full-alpha stroke after fade-in completes
      if (Spiro.segmentCount === 50) {
        orbCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha.toFixed(3)})`;
      }
    }

    Spiro.prevPoint = { x, y };
  }

  orbCtx.restore();

  // Sync Joy logo colour with graph stroke
  document.getElementById('joy-logo').style.color = `rgba(${r}, ${g}, ${b}, 0.55)`;

  requestAnimationFrame(spiroFrame);
}

function spiroStart() {
  if (Spiro.running) return;
  Spiro.running = true;
  spiroRecalcTargets();
  // Fill canvas with cream background
  const W = orbCanvas.width, H = orbCanvas.height;
  orbCtx.fillStyle = 'hsl(38, 30%, 93%)';
  orbCtx.fillRect(0, 0, W, H);
  requestAnimationFrame(spiroFrame);
  // Show mute button immediately (before audio — ensures visibility)
  document.getElementById('sound-toggle').classList.add('visible');
  // Start ambient soundscape (wrapped — never blocks button)
  // On iOS, sound won't play until touchend unlocks the AudioContext.
  // The pendingStart pattern in SoundEngine handles this automatically.
  try { SoundEngine.start(); } catch(e) {}
}

function spiroReset() {
  Spiro.t = 0;
  Spiro.prevPoint = null;
  Spiro.segmentCount = 0;
  Spiro.hasBurst = false;
  Spiro.fillPhase = false;
  Spiro.fillFrames = 0;
  spiroRecalcTargets();
  // Immediately set current params to targets (no lerp on reset)
  Spiro.energy = Spiro.tEnergy;
  Spiro.mood = Spiro.tMood;
  Spiro.stress = Spiro.tStress;
  Spiro.sleep = Spiro.tSleep;
  Spiro.load = Spiro.tLoad;
  // Clear canvas to cream
  const W = orbCanvas.width, H = orbCanvas.height;
  if (W > 0 && H > 0) {
    orbCtx.fillStyle = 'hsl(38, 30%, 93%)';
    orbCtx.fillRect(0, 0, W, H);
  }
}

// (burst removed — pattern builds continuously via normal drawing)

// ═══════════════════════════════════════════════════════════════
// EXPORT
// ═══════════════════════════════════════════════════════════════
const EXPORT_SCALE = 3;

// ═══ DOWNLOAD HELPERS ═══
const IS_MOBILE = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)
  || (navigator.maxTouchPoints > 1 && /Mac/.test(navigator.platform));

function triggerDownload(blob, ext) {
  const fname = 'joy-sort-' + dateStr.replace(/\s/g, '-').toLowerCase() + '.' + ext;
  const u = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = u; a.download = fname;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  setTimeout(() => URL.revokeObjectURL(u), 10000);
}

function showShareHint(msg) {
  let el = document.getElementById('share-hint');
  if (!el) {
    el = document.createElement('div');
    el.id = 'share-hint';
    Object.assign(el.style, {
      position: 'fixed', bottom: '24px', left: '50%', transform: 'translateX(-50%)',
      background: 'rgba(42,37,32,0.9)', color: '#f4efe5', padding: '12px 20px',
      borderRadius: '12px', fontSize: '13px', fontFamily: "'Plus Jakarta Sans', sans-serif",
      zIndex: '9999', opacity: '0', transition: 'opacity 0.3s ease',
      maxWidth: '320px', textAlign: 'center', pointerEvents: 'none'
    });
    document.body.appendChild(el);
  }
  el.textContent = msg;
  el.style.opacity = '1';
  setTimeout(() => { el.style.opacity = '0'; }, 4000);
}

async function downloadCardPng() {
  const blob = await getCardPngBlob();
  if (!blob) return;
  // On mobile: native share sheet gives "Save Image" → Camera Roll
  if (IS_MOBILE) {
    const fname = 'joy-sort-' + dateStr.replace(/\s/g, '-').toLowerCase() + '.png';
    const file = new File([blob], fname, { type: 'image/png' });
    if (navigator.canShare && navigator.canShare({ files: [file] })) {
      try { await navigator.share({ files: [file] }); return; } catch (_) {}
    }
  }
  triggerDownload(blob, 'png');
}

// ═══════════════════════════════════════════════════════════════
// SHARE SHEET
// ═══════════════════════════════════════════════════════════════
let sheetDragStartY = 0;
let sheetDragCurrentY = 0;

function openShareSheet() {
  // Hide Instagram row on desktop (needs native share sheet to route to IG)
  const igRow = document.getElementById('share-instagram');
  if (!IS_MOBILE) igRow.style.display = 'none';

  document.getElementById('share-backdrop').classList.add('visible');
  document.getElementById('share-sheet').classList.add('visible');

  // Swipe to dismiss
  const sheet = document.getElementById('share-sheet');
  sheet.addEventListener('pointerdown', onSheetDragStart);
}

function closeShareSheet() {
  document.getElementById('share-backdrop').classList.remove('visible');
  const sheet = document.getElementById('share-sheet');
  sheet.classList.remove('visible');
  sheet.style.transform = '';
  sheet.removeEventListener('pointerdown', onSheetDragStart);
}

function onSheetDragStart(e) {
  if (e.target.closest('.share-row')) return;
  sheetDragStartY = e.clientY;
  const sheet = document.getElementById('share-sheet');
  sheet.setPointerCapture(e.pointerId);
  sheet.addEventListener('pointermove', onSheetDragMove);
  sheet.addEventListener('pointerup', onSheetDragEnd);
}
function onSheetDragMove(e) {
  const dy = Math.max(0, e.clientY - sheetDragStartY);
  sheetDragCurrentY = dy;
  const sheet = document.getElementById('share-sheet');
  sheet.style.transition = 'none';
  sheet.style.transform = `translateX(-50%) translateY(${dy}px)`;
}
function onSheetDragEnd(e) {
  const sheet = document.getElementById('share-sheet');
  sheet.style.transition = '';
  sheet.removeEventListener('pointermove', onSheetDragMove);
  sheet.removeEventListener('pointerup', onSheetDragEnd);
  if (sheetDragCurrentY > 80) {
    closeShareSheet();
  } else {
    sheet.style.transform = 'translateX(-50%) translateY(0)';
  }
  sheetDragCurrentY = 0;
}

// Shared helper: generate PNG blob with text overlay
async function getCardPngBlob() {
  await document.fonts.ready;
  return new Promise(resolve => {
    const card = document.getElementById('card');
    const s = EXPORT_SCALE;
    const w = Math.round(card.offsetWidth * s);
    const h = Math.round(card.offsetHeight * s);
    const comp = document.createElement('canvas');
    comp.width = w; comp.height = h;
    const ctx = comp.getContext('2d');
    ctx.drawImage(orbCanvas, 0, 0, w, h);

    // Paint reveal text if visible
    const revealEl = document.getElementById('reveal-overlay');
    if (revealEl.classList.contains('visible')) {
      const glow = computeGlow(P);
      const cx = w / 2;
      const cardRect = card.getBoundingClientRect();

      const drawText = (el, text, font, color) => {
        const rect = el.getBoundingClientRect();
        const y = (rect.top - cardRect.top + rect.height / 2) * s;
        ctx.font = font;
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const maxW = w - 64 * s;
        const words = text.split(' ');
        const lines = [];
        let line = '';
        for (const word of words) {
          const test = line ? line + ' ' + word : word;
          if (ctx.measureText(test).width > maxW && line) { lines.push(line); line = word; }
          else line = test;
        }
        if (line) lines.push(line);
        const fontSize = parseFloat(font.match(/(\d+(?:\.\d+)?)px/)[1]);
        const lh = fontSize * 1.4;
        const startY = y - ((lines.length - 1) * lh) / 2;
        lines.forEach((l, i) => ctx.fillText(l, cx, startY + i * lh));
      };

      drawText(document.getElementById('reveal-date'), dateStr, `500 ${11*s}px 'Plus Jakarta Sans', sans-serif`, 'rgba(42,37,32,0.45)');
      drawText(document.getElementById('reveal-capacity'), glow.capacityLine, `600 ${28*s}px 'Source Serif 4', serif`, 'rgba(42,37,32,0.78)');
      drawText(document.getElementById('reveal-timing'), glow.timingLine, `400 ${15*s}px 'Source Serif 4', serif`, 'rgba(42,37,32,0.55)');
      drawText(document.getElementById('reveal-nudge'), glow.nudgeLine, `italic 400 ${15*s}px 'Source Serif 4', serif`, 'rgba(105,78,32,0.50)');

      // feeljoy.ai branding at bottom of export
      ctx.font = `500 ${10*s}px 'Plus Jakarta Sans', sans-serif`;
      ctx.fillStyle = 'rgba(42,37,32,0.25)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('feeljoy.ai', cx, h - 28 * s);
    }

    comp.toBlob(b => resolve(b), 'image/png');
  });
}

function getGlowShareFile() {
  return getCardPngBlob().then(blob => {
    const fname = 'joy-sort-' + dateStr.replace(/\s/g, '-').toLowerCase() + '.png';
    return new File([blob], fname, { type: 'image/png' });
  });
}

function getGlowText() {
  const g = computeGlow(P);
  return `${g.capacityLine}\n${g.timingLine}\n${g.nudgeLine}`;
}

// Share to Instagram Stories via native share sheet (mobile only)
async function shareInstagram() {
  closeShareSheet();
  const blob = await getCardPngBlob();
  if (!blob) return;
  const fname = 'joy-sort-' + dateStr.replace(/\s/g, '-').toLowerCase() + '.png';
  const file = new File([blob], fname, { type: 'image/png' });
  if (IS_MOBILE && navigator.canShare && navigator.canShare({ files: [file] })) {
    try {
      await navigator.share({ files: [file], title: 'My Glow' });
      return;
    } catch (e) { if (e.name === 'AbortError') return; }
  }
  triggerDownload(blob, 'png');
}

// Post to X — native share on mobile, else save image + open tweet intent
async function shareTwitter() {
  closeShareSheet();
  const text = getGlowText() + '\nfeeljoy.ai';
  const blob = await getCardPngBlob();
  if (!blob) return;
  const fname = 'joy-sort-' + dateStr.replace(/\s/g, '-').toLowerCase() + '.png';
  const file = new File([blob], fname, { type: 'image/png' });
  if (IS_MOBILE && navigator.canShare && navigator.canShare({ files: [file] })) {
    try {
      await navigator.share({ files: [file], text });
      return;
    } catch (e) { if (e.name === 'AbortError') return; }
  }
  triggerDownload(blob, 'png');
  window.open('https://twitter.com/intent/tweet?text=' + encodeURIComponent(text), '_blank');
}

// Share on LinkedIn — mobile: native share (routes to LI app), desktop: clipboard + open LI
async function shareLinkedIn() {
  closeShareSheet();
  const blob = await getCardPngBlob();
  if (!blob) return;
  const text = getGlowText() + '\nfeeljoy.ai';
  const fname = 'joy-sort-' + dateStr.replace(/\s/g, '-').toLowerCase() + '.png';
  const file = new File([blob], fname, { type: 'image/png' });
  // Mobile: native share sheet — user picks LinkedIn app directly
  if (IS_MOBILE && navigator.canShare && navigator.canShare({ files: [file] })) {
    try {
      await navigator.share({ files: [file], text });
      return;
    } catch (e) { if (e.name === 'AbortError') return; }
  }
  // Desktop: copy image + text to clipboard, open LinkedIn
  let copied = false;
  try {
    if (navigator.clipboard && navigator.clipboard.write && typeof ClipboardItem !== 'undefined') {
      await navigator.clipboard.write([new ClipboardItem({
        'image/png': blob,
        'text/plain': new Blob([text], { type: 'text/plain' })
      })]);
      copied = true;
    }
  } catch (_) {}
  if (!copied) {
    triggerDownload(blob, 'png');
    try { if (navigator.clipboard) await navigator.clipboard.writeText(text); } catch (_) {}
  }
  window.open('https://www.linkedin.com/feed/', '_blank');
  showShareHint(copied
    ? 'Image + text copied — paste into your LinkedIn post'
    : 'Image saved, text copied — paste into your post and attach the image');
}

// Copy glow image to clipboard (falls back to text if clipboard image not supported)
// iOS Safari requires passing a Promise to ClipboardItem to preserve user gesture context.
async function copyGlowText() {
  const label = document.getElementById('copy-glow-label');
  try {
    if (navigator.clipboard && navigator.clipboard.write && typeof ClipboardItem !== 'undefined') {
      // Pass the blob promise directly — preserves user gesture on Safari
      const item = new ClipboardItem({ 'image/png': getCardPngBlob().then(b => b || new Blob()) });
      await navigator.clipboard.write([item]);
      label.textContent = 'copied \u2713';
    } else if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(getGlowText());
      label.textContent = 'copied text \u2713';
    }
  } catch (e) {
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(getGlowText());
        label.textContent = 'copied text \u2713';
      }
    } catch (_) { /* silently fail */ }
  }
  setTimeout(() => { label.textContent = 'copy image'; }, 2000);
}

// ═══════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════
window.addEventListener('resize', () => {
  sizeOrbCanvas();
  // Re-update slider positions on resize
  document.querySelectorAll('.slider-wrap').forEach(wrap => {
    const key = wrap.dataset.key;
    if (P[key]) {
      const thumb = wrap.querySelector('.slider-thumb');
      const fill = wrap.querySelector('.slider-fill');
      thumb.style.transition = 'none';
      fill.style.transition = 'none';
      updateSliderVisual(wrap, P[key]);
      requestAnimationFrame(() => {
        thumb.style.transition = '';
        fill.style.transition = '';
      });
    }
  });
});

// Size canvas and fill cream background (but don't start drawing yet)
sizeOrbCanvas();

// Show first slider and progress dots
document.getElementById('checkin-progress').classList.add('visible');
currentMoment = 0;
updateDots();

// Initialize sliders
initSliders();

// Initialize slider visuals after layout
requestAnimationFrame(() => {
  document.querySelectorAll('.slider-wrap').forEach(wrap => {
    const key = wrap.dataset.key;
    if (P[key] != null) updateSliderVisual(wrap, P[key]);
  });
});
</script>
</body>
</html>
